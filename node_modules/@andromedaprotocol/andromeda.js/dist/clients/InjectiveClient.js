"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const cosmwasm_stargate_1 = require("@cosmjs/cosmwasm-stargate");
const crypto_1 = require("@cosmjs/crypto");
const encoding_1 = require("@cosmjs/encoding");
const logs_1 = require("@cosmjs/stargate/build/logs");
const networks_1 = require("@injectivelabs/networks");
const sdk_ts_1 = require("@injectivelabs/sdk-ts");
const utils_1 = require("@injectivelabs/utils");
const lodash_1 = __importDefault(require("lodash"));
const long_1 = __importDefault(require("long"));
const pako_1 = require("pako");
const BaseChainClient_1 = __importDefault(require("./BaseChainClient"));
function arrayToJson(array) {
    const jsonString = Buffer.from(array).toString("utf8");
    const parsedData = JSON.parse(jsonString);
    return parsedData;
}
function mapObjToEnjClass(type, value) {
    switch (type) {
        case "MsgInstantiateContract":
            return sdk_ts_1.MsgInstantiateContract.fromJSON({
                sender: value.sender,
                admin: value.sender,
                codeId: value.codeId,
                label: value.label,
                // Msg is encoded as Uint8Array, convert back to JSON here
                msg: arrayToJson(value.msg),
                amount: value.amount,
            });
        case "MsgExecuteContract":
            return sdk_ts_1.MsgExecuteContract.fromJSON({
                funds: value.funds,
                sender: value.sender,
                contractAddress: value.contract,
                msg: arrayToJson(value.msg),
            });
        case "MsgMigrateContract":
            return sdk_ts_1.MsgMigrateContract.fromJSON({
                sender: value.sender,
                contract: value.contract,
                codeId: value.codeId,
                msg: arrayToJson(value.msg),
            });
        case "MsgSend":
            return sdk_ts_1.MsgSend.fromJSON({
                amount: value.amount[0],
                srcInjectiveAddress: value.fromAddress,
                dstInjectiveAddress: value.toAddress,
            });
        case "MsgStoreCode":
        default:
            return sdk_ts_1.MsgStoreCode.fromJSON({
                sender: value.sender,
                wasmBytes: value.wasmByteCode,
            });
    }
}
function encodeObjectToMsgArgs(msgs) {
    return msgs.map((msg) => {
        const type = lodash_1.default.last(msg.typeUrl.split("."));
        return mapObjToEnjClass(type, msg.value).toDirectSign();
    });
}
class InjectiveClient extends BaseChainClient_1.default {
    preMessage(signed = true) {
        super.preMessage(signed);
        if (signed && !this.directSigner) {
            throw new Error("No signer assigned");
        }
    }
    async connect(endpoint, signer) {
        delete this.signingClient;
        delete this.queryClient;
        const network = endpoint.includes("testnet")
            ? networks_1.Network.TestnetK8s
            : networks_1.Network.MainnetK8s;
        this.chainId = (0, networks_1.getNetworkChainInfo)(network).chainId;
        const { rest, rpc, grpc } = (0, networks_1.getNetworkEndpoints)(network);
        this.queryClient = await cosmwasm_stargate_1.CosmWasmClient.connect(rpc);
        this.chainRestTendermintApi = new sdk_ts_1.ChainRestTendermintApi(rest);
        this.chainRestAuthApi = new sdk_ts_1.ChainRestAuthApi(rest);
        if (signer) {
            this.signingClient = new sdk_ts_1.TxGrpcClient(grpc);
            this.directSigner = signer;
            const [account] = await signer.getAccounts();
            this.signer = account.address;
        }
    }
    async disconnect() {
        delete this.signingClient;
        this.queryClient?.disconnect();
        delete this.queryClient;
        this.signer = "";
        delete this.directSigner;
        delete this.gasPrice;
        delete this.chainRestTendermintApi;
        delete this.chainRestAuthApi;
    }
    async getTimeoutHeight() {
        if (!this.chainRestTendermintApi)
            throw new Error("Chain Tendermint Rest API not connected");
        const latestBlock = await this.chainRestTendermintApi.fetchLatestBlock();
        const latestHeight = latestBlock.header.height;
        return new utils_1.BigNumberInBase(latestHeight)
            .plus(utils_1.DEFAULT_BLOCK_TIMEOUT_HEIGHT)
            .toNumber();
    }
    async getBaseAccount() {
        if (!this.chainRestAuthApi)
            throw new Error("Chain Auth Rest API not connected");
        const accountDetailsResponse = await this.chainRestAuthApi.fetchAccount(this.signer);
        const baseAccount = sdk_ts_1.BaseAccount.fromRestApi(accountDetailsResponse);
        return baseAccount.toAccountDetails();
    }
    async getPubKey() {
        const [account] = await this.directSigner.getAccounts();
        return Buffer.from(account.pubkey).toString("base64");
    }
    async signInj(messages, fee = (0, utils_1.getStdFee)(utils_1.DEFAULT_GAS_LIMIT.toString()), memo = "", simulation = false) {
        this.preMessage();
        const timeoutHeight = await this.getTimeoutHeight();
        const baseAccount = await this.getBaseAccount();
        const pubKey = await this.getPubKey();
        const { signDoc, txRaw } = (0, sdk_ts_1.createTransaction)({
            pubKey,
            chainId: this.chainId,
            message: encodeObjectToMsgArgs(messages),
            timeoutHeight,
            sequence: baseAccount.sequence,
            accountNumber: baseAccount.accountNumber,
            memo,
            fee,
        });
        if (simulation)
            return txRaw;
        const signed = await this.directSigner.signDirect(this.signer, {
            ...signDoc,
            chainId: signDoc.getChainId(),
            bodyBytes: signDoc.getBodyBytes_asU8(),
            authInfoBytes: signDoc.getAuthInfoBytes_asU8(),
            accountNumber: long_1.default.fromInt(baseAccount.accountNumber),
        });
        return (0, sdk_ts_1.createTxRawFromSigResponse)(signed);
    }
    async sign(messages, fee, memo) {
        const injTxRaw = await this.signInj(messages, fee, memo);
        return {
            bodyBytes: injTxRaw.getBodyBytes_asU8(),
            authInfoBytes: injTxRaw.getAuthInfoBytes_asU8(),
            signatures: injTxRaw.getSignaturesList_asU8(),
        };
    }
    async broadcast(tx, timeoutMs = 60000, pollIntervalMs = 3000) {
        const resp = await this.signingClient.broadcastBlock(tx);
        //This code is duplicated from the CosmWasmClient to correct return types
        let timedOut = false;
        const txPollTimeout = setTimeout(() => {
            timedOut = true;
        }, timeoutMs);
        const pollTx = async (txId) => {
            if (timedOut)
                throw new Error(`Transaction with ID ${txId} was submitted but was not yet found on the chain. You might want to check later. There was a wait of ${timeoutMs / 1000} seconds`);
            await (0, utils_1.sleep)(pollIntervalMs);
            const result = await this.queryClient.getTx(txId);
            return result
                ? { ...result, transactionHash: result.hash }
                : pollTx(txId);
        };
        return new Promise((resolve, reject) => pollTx(resp.txHash).then((val) => {
            clearTimeout(txPollTimeout);
            resolve(val);
        }, (err) => {
            clearTimeout(txPollTimeout);
            reject(err);
        }));
    }
    async signAndBroadcast(messages, fee, memo) {
        const signed = await this.signInj(messages, fee === "auto" ? undefined : fee, memo);
        const resp = await this.broadcast(signed);
        return {
            ...resp,
            logs: (0, logs_1.parseRawLog)(resp.rawLog),
        };
    }
    // Saving this here for potential refactor for extra functionality
    // async simulateMulti(messages: EncodeObject[], fee: StdFee, memo = "") {
    //   const txRaw = await this.signInj(messages, fee, memo);
    //   const resp = await this.signingClient!.simulate(txRaw);
    //   // TODO: CHECK THIS RESPONSE OBJECT AS IT MAY BE INVALID
    //   return {
    //     ...resp,
    //     result: {
    //       ...resp.result,
    //       data: Buffer.from(resp.result.data),
    //       events: resp.result.eventsList.map((ev) => ({
    //         ...ev,
    //         attributes: ev.attributes.map((attr) => ({
    //           key: Buffer.from(attr.key),
    //           value: Buffer.from(attr.value),
    //           index: false,
    //         })),
    //       })),
    //     },
    //     gasInfo: {
    //       gasUsed: Long.fromNumber(resp.gasInfo.gasUsed),
    //       gasWanted: Long.fromNumber(resp.gasInfo.gasWanted),
    //     },
    //   };
    // }
    async simulateMulti(messages, fee, memo = "") {
        const txRaw = await this.signInj(messages, fee, memo, true);
        const resp = await this.signingClient.simulate(txRaw);
        // TODO: CHECK THIS RESPONSE OBJECT AS IT MAY BE INVALID
        return resp.gasInfo.gasUsed;
    }
    async simulate(message, fee, memo = "") {
        return this.simulateMulti([message], fee, memo);
    }
    async execute(contractAddress, msg, fee, memo, funds = []) {
        const message = this.encodeExecuteMsg(contractAddress, msg, funds);
        return await this.signAndBroadcast([message], fee, memo);
    }
    async simulateExecute(address, msg, funds, fee, memo) {
        const message = this.encodeExecuteMsg(address, msg, funds);
        return this.simulate(message, fee, memo);
    }
    async upload(code, fee, memo = "") {
        const compressed = (0, pako_1.gzip)(code, { level: 9 });
        const message = this.encodeUploadMessage(compressed);
        const resp = await this.signAndBroadcast([message], fee, memo);
        const codeIdAttr = (0, logs_1.findAttribute)(resp.logs, "store_code", "code_id");
        const originalChecksum = (0, encoding_1.toHex)((0, crypto_1.sha256)(code));
        const compressedChecksum = (0, encoding_1.toHex)((0, crypto_1.sha256)(compressed));
        return {
            ...resp,
            codeId: parseInt(codeIdAttr.value, 10),
            originalSize: code.length,
            originalChecksum,
            compressedSize: compressed.length,
            compressedChecksum,
        };
    }
    async simulateUpload(code, fee, memo) {
        const compressed = (0, pako_1.gzip)(code, { level: 9 });
        const message = this.encodeUploadMessage(compressed);
        return this.simulate(message, fee, memo);
    }
    async instantiate(codeId, msg, label, fee, options) {
        const message = this.encodeInstantiateMsg(codeId, msg, label);
        const resp = await this.signAndBroadcast([message], fee, options ? options.memo : "");
        const contractAddressAttr = (0, logs_1.findAttribute)(resp.logs, "wasm", "_contract_address");
        return {
            ...resp,
            contractAddress: contractAddressAttr.value,
        };
    }
    async simulateInstantiate(codeId, msg, label, fee, options) {
        const message = this.encodeInstantiateMsg(codeId, msg, label);
        return this.simulate(message, fee, options?.memo);
    }
    async migrate(contractAddress, codeId, msg, fee, memo) {
        const message = this.encodeMigrateMessage(contractAddress, codeId, msg);
        const resp = await this.signAndBroadcast([message], fee, memo);
        return resp;
    }
    async simulateMigrate(contractAddress, codeId, msg, fee, memo) {
        const message = this.encodeMigrateMessage(contractAddress, codeId, msg);
        return this.simulate(message, fee, memo);
    }
    async sendTokens(receivingAddress, amount, fee, memo) {
        if (amount.length > 1)
            throw new Error("Injective only enables the sending of one amount at a time, please only send one token type.");
        const message = this.encodeSendMessage(receivingAddress, [...amount]);
        return this.signAndBroadcast([message], fee, memo);
    }
}
exports.default = InjectiveClient;
