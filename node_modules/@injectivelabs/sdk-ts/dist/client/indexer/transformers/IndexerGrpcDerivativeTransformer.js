"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.IndexerGrpcDerivativeTransformer = void 0;
const ts_types_1 = require("@injectivelabs/ts-types");
const utils_1 = require("@injectivelabs/utils");
const pagination_1 = require("../../../utils/pagination");
const zeroPositionDelta = () => ({
    tradeDirection: ts_types_1.TradeDirection.Buy,
    executionPrice: '0',
    executionQuantity: '0',
    executionMargin: '0',
});
/**
 * @category Indexer Grpc Transformer
 */
class IndexerGrpcDerivativeTransformer {
    static grpcTokenMetaToTokenMeta(tokenMeta) {
        if (!tokenMeta) {
            return;
        }
        return {
            name: tokenMeta.getName(),
            address: tokenMeta.getAddress(),
            symbol: tokenMeta.getSymbol(),
            logo: tokenMeta.getLogo(),
            decimals: tokenMeta.getDecimals(),
            updatedAt: tokenMeta.getUpdatedAt(),
            coinGeckoId: '',
        };
    }
    static grpcPerpetualMarketInfoToPerpetualMarketInfo(perpetualMarketInfo) {
        if (!perpetualMarketInfo) {
            return;
        }
        return {
            hourlyFundingRateCap: perpetualMarketInfo.getHourlyFundingRateCap(),
            hourlyInterestRate: perpetualMarketInfo.getHourlyInterestRate(),
            nextFundingTimestamp: perpetualMarketInfo.getNextFundingTimestamp(),
            fundingInterval: perpetualMarketInfo.getFundingInterval(),
        };
    }
    static grpcPerpetualMarketFundingToPerpetualMarketFunding(perpetualMarketFunding) {
        if (!perpetualMarketFunding) {
            return;
        }
        return {
            cumulativeFunding: perpetualMarketFunding.getCumulativeFunding(),
            cumulativePrice: perpetualMarketFunding.getCumulativePrice(),
            lastTimestamp: perpetualMarketFunding.getLastTimestamp(),
        };
    }
    static grpcExpiryFuturesMarketInfoToExpiryFuturesMarketInfo(expiryFuturesMarketInfo) {
        if (!expiryFuturesMarketInfo) {
            return;
        }
        return {
            expirationTimestamp: expiryFuturesMarketInfo.getExpirationTimestamp(),
            settlementPrice: expiryFuturesMarketInfo.getSettlementPrice(),
        };
    }
    static marketResponseToMarket(response) {
        const market = response.getMarket();
        return IndexerGrpcDerivativeTransformer.grpcMarketToMarket(market);
    }
    static marketsResponseToMarkets(response) {
        const markets = response.getMarketsList();
        return IndexerGrpcDerivativeTransformer.grpcMarketsToMarkets(markets);
    }
    static ordersResponseToOrders(response) {
        const orders = response.getOrdersList();
        const pagination = response.getPaging();
        return {
            orders: IndexerGrpcDerivativeTransformer.grpcOrdersToOrders(orders),
            pagination: (0, pagination_1.grpcPagingToPaging)(pagination),
        };
    }
    static orderHistoryResponseToOrderHistory(response) {
        const orderHistory = response.getOrdersList();
        const pagination = response.getPaging();
        return {
            orderHistory: IndexerGrpcDerivativeTransformer.grpcOrderHistoryListToOrderHistoryList(orderHistory),
            pagination: (0, pagination_1.grpcPagingToPaging)(pagination),
        };
    }
    static positionsResponseToPositions(response) {
        const positions = response.getPositionsList();
        const pagination = response.getPaging();
        return {
            positions: IndexerGrpcDerivativeTransformer.grpcPositionsToPositions(positions),
            pagination: (0, pagination_1.grpcPagingToPaging)(pagination),
        };
    }
    static tradesResponseToTrades(response) {
        const trades = response.getTradesList();
        const pagination = response.getPaging();
        return {
            trades: IndexerGrpcDerivativeTransformer.grpcTradesToTrades(trades),
            pagination: (0, pagination_1.grpcPagingToPaging)(pagination),
        };
    }
    static subaccountTradesListResponseToSubaccountTradesList(response) {
        const tradesList = response.getTradesList();
        return IndexerGrpcDerivativeTransformer.grpcTradesToTrades(tradesList);
    }
    static fundingPaymentsResponseToFundingPayments(response) {
        const fundingPayments = response.getPaymentsList();
        const pagination = response.getPaging();
        return {
            fundingPayments: IndexerGrpcDerivativeTransformer.grpcFundingPaymentsToFundingPayments(fundingPayments),
            pagination: (0, pagination_1.grpcPagingToPaging)(pagination),
        };
    }
    static fundingRatesResponseToFundingRates(response) {
        const fundingRates = response.getFundingRatesList();
        const pagination = response.getPaging();
        return {
            fundingRates: IndexerGrpcDerivativeTransformer.grpcFundingRatesToFundingRates(fundingRates),
            pagination: (0, pagination_1.grpcPagingToPaging)(pagination),
        };
    }
    static orderbookResponseToOrderbook(response) {
        const orderbook = response.getOrderbook();
        return IndexerGrpcDerivativeTransformer.grpcOrderbookToOrderbook({
            buys: orderbook === null || orderbook === void 0 ? void 0 : orderbook.getBuysList(),
            sells: orderbook === null || orderbook === void 0 ? void 0 : orderbook.getSellsList(),
        });
    }
    static orderbookV2ResponseToOrderbookV2(response) {
        const orderbook = response.getOrderbook();
        return IndexerGrpcDerivativeTransformer.grpcOrderbookV2ToOrderbookV2({
            sequence: orderbook.getSequence(),
            buys: orderbook === null || orderbook === void 0 ? void 0 : orderbook.getBuysList(),
            sells: orderbook === null || orderbook === void 0 ? void 0 : orderbook.getSellsList(),
        });
    }
    static orderbooksResponseToOrderbooks(response) {
        const orderbooks = response.getOrderbooksList();
        return orderbooks.map((o) => {
            const orderbook = o.getOrderbook();
            return {
                marketId: o.getMarketId(),
                orderbook: IndexerGrpcDerivativeTransformer.grpcOrderbookToOrderbook({
                    buys: orderbook.getBuysList(),
                    sells: orderbook.getSellsList(),
                }),
            };
        });
    }
    static orderbooksV2ResponseToOrderbooksV2(response) {
        const orderbooks = response.getOrderbooksList();
        return orderbooks.map((o) => {
            const orderbook = o.getOrderbook();
            return {
                marketId: o.getMarketId(),
                orderbook: IndexerGrpcDerivativeTransformer.grpcOrderbookV2ToOrderbookV2({
                    sequence: orderbook.getSequence(),
                    buys: orderbook.getBuysList(),
                    sells: orderbook.getSellsList(),
                }),
            };
        });
    }
    static binaryOptionsMarketResponseToBinaryOptionsMarket(response) {
        const market = response.getMarket();
        return IndexerGrpcDerivativeTransformer.grpcBinaryOptionsMarketToBinaryOptionsMarket(market);
    }
    static binaryOptionsMarketResponseWithPaginationToBinaryOptionsMarket(response) {
        const markets = response.getMarketsList();
        const pagination = response.getPaging();
        return {
            markets: IndexerGrpcDerivativeTransformer.grpcBinaryOptionsMarketsToBinaryOptionsMarkets(markets),
            pagination: (0, pagination_1.grpcPagingToPaging)(pagination),
        };
    }
    static binaryOptionsMarketsResponseToBinaryOptionsMarkets(response) {
        const markets = response.getMarketsList();
        return IndexerGrpcDerivativeTransformer.grpcBinaryOptionsMarketsToBinaryOptionsMarkets(markets);
    }
    static grpcBinaryOptionsMarketToBinaryOptionsMarket(market) {
        return {
            marketId: market.getMarketId(),
            marketStatus: market.getMarketStatus(),
            ticker: market.getTicker(),
            oracleSymbol: market.getOracleSymbol(),
            oracleProvider: market.getOracleProvider(),
            oracleType: market.getOracleType(),
            oracleScaleFactor: market.getOracleScaleFactor(),
            expirationTimestamp: market.getExpirationTimestamp(),
            settlementTimestamp: market.getSettlementTimestamp(),
            quoteDenom: market.getQuoteDenom(),
            quoteToken: IndexerGrpcDerivativeTransformer.grpcTokenMetaToTokenMeta(market.getQuoteTokenMeta()),
            makerFeeRate: market.getMakerFeeRate(),
            takerFeeRate: market.getTakerFeeRate(),
            serviceProviderFee: market.getServiceProviderFee(),
            minPriceTickSize: market.getMinPriceTickSize(),
            minQuantityTickSize: market.getMinQuantityTickSize(),
            settlementPrice: market.getSettlementPrice(),
        };
    }
    static grpcBinaryOptionsMarketsToBinaryOptionsMarkets(markets) {
        return markets.map(IndexerGrpcDerivativeTransformer.grpcBinaryOptionsMarketToBinaryOptionsMarket);
    }
    static grpcMarketToMarket(market) {
        return {
            oracleBase: market.getOracleBase(),
            oracleQuote: market.getOracleQuote(),
            oracleType: market.getOracleType(),
            oracleScaleFactor: market.getOracleScaleFactor(),
            initialMarginRatio: market.getInitialMarginRatio(),
            maintenanceMarginRatio: market.getMaintenanceMarginRatio(),
            isPerpetual: market.getIsPerpetual(),
            marketId: market.getMarketId(),
            marketStatus: market.getMarketStatus(),
            ticker: market.getTicker(),
            quoteDenom: market.getQuoteDenom(),
            quoteToken: IndexerGrpcDerivativeTransformer.grpcTokenMetaToTokenMeta(market.getQuoteTokenMeta()),
            makerFeeRate: market.getMakerFeeRate(),
            takerFeeRate: market.getTakerFeeRate(),
            serviceProviderFee: market.getServiceProviderFee(),
            minPriceTickSize: new utils_1.BigNumber(market.getMinPriceTickSize()).toNumber(),
            minQuantityTickSize: new utils_1.BigNumber(market.getMinQuantityTickSize()).toNumber(),
            perpetualMarketInfo: IndexerGrpcDerivativeTransformer.grpcPerpetualMarketInfoToPerpetualMarketInfo(market.getPerpetualMarketInfo()),
            perpetualMarketFunding: IndexerGrpcDerivativeTransformer.grpcPerpetualMarketFundingToPerpetualMarketFunding(market.getPerpetualMarketFunding()),
            expiryFuturesMarketInfo: IndexerGrpcDerivativeTransformer.grpcExpiryFuturesMarketInfoToExpiryFuturesMarketInfo(market.getExpiryFuturesMarketInfo()),
        };
    }
    static grpcMarketsToMarkets(markets) {
        return markets.map((market) => IndexerGrpcDerivativeTransformer.grpcMarketToMarket(market));
    }
    static grpcPositionDeltaToPositionDelta(positionDelta) {
        return {
            tradeDirection: positionDelta.getTradeDirection(),
            executionPrice: positionDelta.getExecutionPrice(),
            executionQuantity: positionDelta.getExecutionQuantity(),
            executionMargin: positionDelta.getExecutionMargin(),
        };
    }
    static grpcPriceLevelToPriceLevel(priceLevel) {
        return {
            price: priceLevel.getPrice(),
            quantity: priceLevel.getQuantity(),
            timestamp: priceLevel.getTimestamp(),
        };
    }
    static grpcPriceLevelsToPriceLevels(priceLevels) {
        return priceLevels.map((priceLevel) => IndexerGrpcDerivativeTransformer.grpcPriceLevelToPriceLevel(priceLevel));
    }
    static grpcOrderbookToOrderbook({ buys, sells, }) {
        return {
            buys: IndexerGrpcDerivativeTransformer.grpcPriceLevelsToPriceLevels(buys),
            sells: IndexerGrpcDerivativeTransformer.grpcPriceLevelsToPriceLevels(sells),
        };
    }
    static grpcOrderbookV2ToOrderbookV2({ sequence, buys, sells, }) {
        return {
            sequence,
            buys: IndexerGrpcDerivativeTransformer.grpcPriceLevelsToPriceLevels(buys),
            sells: IndexerGrpcDerivativeTransformer.grpcPriceLevelsToPriceLevels(sells),
        };
    }
    static grpcOrderToOrder(order) {
        return {
            orderHash: order.getOrderHash(),
            orderSide: order.getOrderSide(),
            marketId: order.getMarketId(),
            subaccountId: order.getSubaccountId(),
            isReduceOnly: order.getIsReduceOnly(),
            margin: order.getMargin(),
            price: order.getPrice(),
            quantity: order.getQuantity(),
            unfilledQuantity: order.getUnfilledQuantity(),
            triggerPrice: order.getTriggerPrice(),
            feeRecipient: order.getFeeRecipient(),
            state: order.getState(),
            createdAt: order.getCreatedAt(),
            updatedAt: order.getUpdatedAt(),
            orderNumber: order.getOrderNumber(),
            orderType: order.getOrderType(),
            isConditional: order.getIsConditional(),
            triggerAt: order.getTriggerAt(),
            placedOrderHash: order.getPlacedOrderHash(),
            executionType: order.getExecutionType(),
        };
    }
    static grpcOrdersToOrders(orders) {
        return orders.map((order) => IndexerGrpcDerivativeTransformer.grpcOrderToOrder(order));
    }
    static grpcOrderHistoryToOrderHistory(orderHistory) {
        return {
            orderHash: orderHistory.getOrderHash(),
            marketId: orderHistory.getMarketId(),
            isActive: orderHistory.getIsActive(),
            subaccountId: orderHistory.getSubaccountId(),
            executionType: orderHistory.getExecutionType(),
            orderType: orderHistory.getOrderType(),
            price: orderHistory.getPrice(),
            triggerPrice: orderHistory.getTriggerPrice(),
            quantity: orderHistory.getQuantity(),
            filledQuantity: orderHistory.getFilledQuantity(),
            state: orderHistory.getState(),
            createdAt: orderHistory.getCreatedAt(),
            updatedAt: orderHistory.getUpdatedAt(),
            isReduceOnly: orderHistory.getIsReduceOnly(),
            direction: orderHistory.getDirection(),
            isConditional: orderHistory.getIsConditional(),
            triggerAt: orderHistory.getTriggerAt(),
            placedOrderHash: orderHistory.getPlacedOrderHash(),
            margin: orderHistory.getMargin(),
        };
    }
    static grpcOrderHistoryListToOrderHistoryList(orderHistory) {
        return orderHistory.map((orderHistory) => IndexerGrpcDerivativeTransformer.grpcOrderHistoryToOrderHistory(orderHistory));
    }
    static grpcPositionToPosition(position) {
        return {
            marketId: position.getMarketId(),
            subaccountId: position.getSubaccountId(),
            direction: position.getDirection(),
            quantity: position.getQuantity(),
            entryPrice: position.getEntryPrice(),
            margin: position.getMargin(),
            aggregateReduceOnlyQuantity: position.getAggregateReduceOnlyQuantity(),
            liquidationPrice: position.getLiquidationPrice(),
            markPrice: position.getMarkPrice(),
            ticker: position.getTicker(),
            updatedAt: position.getUpdatedAt(),
        };
    }
    static grpcPositionsToPositions(positions) {
        return positions.map((position) => IndexerGrpcDerivativeTransformer.grpcPositionToPosition(position));
    }
    static grpcTradeToTrade(trade) {
        const positionDelta = trade.getPositionDelta();
        const mappedPositionDelta = positionDelta
            ? IndexerGrpcDerivativeTransformer.grpcPositionDeltaToPositionDelta(positionDelta)
            : zeroPositionDelta();
        return Object.assign({ orderHash: trade.getOrderHash(), tradeId: trade.getTradeId(), subaccountId: trade.getSubaccountId(), marketId: trade.getMarketId(), executedAt: trade.getExecutedAt(), tradeExecutionType: trade.getTradeExecutionType(), executionSide: trade.getExecutionSide(), fee: trade.getFee(), feeRecipient: trade.getFeeRecipient(), isLiquidation: trade.getIsLiquidation(), payout: trade.getPayout() }, mappedPositionDelta);
    }
    static grpcTradesToTrades(trades) {
        return trades.map((trade) => IndexerGrpcDerivativeTransformer.grpcTradeToTrade(trade));
    }
    static grpcFundingPaymentToFundingPayment(fundingPayment) {
        return {
            marketId: fundingPayment.getMarketId(),
            subaccountId: fundingPayment.getSubaccountId(),
            amount: fundingPayment.getAmount(),
            timestamp: fundingPayment.getTimestamp(),
        };
    }
    static grpcFundingPaymentsToFundingPayments(fundingPayments) {
        return fundingPayments.map(IndexerGrpcDerivativeTransformer.grpcFundingPaymentToFundingPayment);
    }
    static grpcFundingRateToFundingRate(fundingRate) {
        return {
            marketId: fundingRate.getMarketId(),
            rate: fundingRate.getRate(),
            timestamp: fundingRate.getTimestamp(),
        };
    }
    static grpcFundingRatesToFundingRates(fundingRates) {
        return fundingRates.map(IndexerGrpcDerivativeTransformer.grpcFundingRateToFundingRate);
    }
}
exports.IndexerGrpcDerivativeTransformer = IndexerGrpcDerivativeTransformer;
//# sourceMappingURL=IndexerGrpcDerivativeTransformer.js.map