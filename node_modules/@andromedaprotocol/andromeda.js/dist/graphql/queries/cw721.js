"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.queryTransferAgreement = exports.QUERY_CW721_TRANSFER_AGREEMENT = exports.queryTokens = exports.QUERY_CW721_TOKENS = exports.queryOwnerOf = exports.QUERY_CW721_OWNER_OF = exports.queryNFTInfo = exports.QUERY_CW721_NFT_INFO = exports.queryIsArchived = exports.QUERY_CW721_IS_ARCHIVED = exports.queryContractInfo = exports.QUERY_CW721_CONTRACT_INFO = exports.queryApprovals = exports.QUERY_CW721_APPROVALS = exports.queryApproval = exports.QUERY_CW721_APPROVAL = exports.queryAllTokens = exports.QUERY_CW721_ALL_TOKENS = exports.queryAllOperators = exports.QUERY_CW721_ALL_OPERATORS = exports.queryAllNFTInfo = exports.QUERY_CW721_ALL_NFT_INFO = exports.TOKEN_EXTENSION_FRAGMENT = void 0;
const client_1 = require("../client");
const graphql_request_1 = require("graphql-request");
exports.TOKEN_EXTENSION_FRAGMENT = (0, graphql_request_1.gql) `
  fragment TokenExtensionInfo on TokenExtension {
    animation_url
    attributes {
      display_type
      trait_type
      value
    }
    description
    external_url
    image
    image_data
    name
    publisher
    youtube_url
  }
`;
exports.QUERY_CW721_ALL_NFT_INFO = (0, graphql_request_1.gql) `
  query QUERY_CW721_ALL_NFT_INFO(
    $contractAddress: String!
    $includeExpired: Boolean!
    $tokenId: String!
  ) {
    cw721(address: $contractAddress) {
      allNftInfo(includeExpired: $includeExpired, tokenId: $tokenId) {
        access {
          approvals {
            expires
            spender
          }
          owner
        }
        info {
          extension {
            ...TokenExtensionInfo
          }
          tokenUri
        }
      }
    }
  }
  ${exports.TOKEN_EXTENSION_FRAGMENT}
`;
/**
 * Queries a CW721 contract for all info for a given token ID
 * @param contractAddress
 * @param tokenId
 * @param includeExpired
 * @returns
 */
async function queryAllNFTInfo(contractAddress, tokenId, includeExpired = false) {
    const resp = await (0, client_1.query)(exports.QUERY_CW721_ALL_NFT_INFO, { contractAddress, tokenId, includeExpired });
    return resp.cw721.allNftInfo;
}
exports.queryAllNFTInfo = queryAllNFTInfo;
exports.QUERY_CW721_ALL_OPERATORS = (0, graphql_request_1.gql) `
  query QUERY_CW721_ALL_OPERATORS(
    $contractAddress: String!
    $includeExpired: Boolean!
    $owner: String!
    $options: AndrSearchOptions
  ) {
    cw721(address: $contractAddress) {
      allOperators(
        includeExpired: $includeExpired
        owner: $owner
        options: $options
      ) {
        expires
        spender
      }
    }
  }
`;
/**
 * Queries a CW721 contract for all approved operators for a given token owner
 * @param contractAddress
 * @param owner
 * @param includeExpired
 * @param options
 * @returns
 */
async function queryAllOperators(contractAddress, owner, includeExpired = false, options) {
    const resp = await (0, client_1.query)(exports.QUERY_CW721_ALL_OPERATORS, {
        contractAddress,
        includeExpired,
        owner,
        options,
    });
    return resp.cw721.allOperators;
}
exports.queryAllOperators = queryAllOperators;
exports.QUERY_CW721_ALL_TOKENS = (0, graphql_request_1.gql) `
  query QUERY_CW721_ALL_TOKENS(
    $contractAddress: String!
    $options: AndrSearchOptions
  ) {
    cw721(address: $contractAddress) {
      allTokens(options: $options)
    }
  }
`;
/**
 * Queries a CW721 contract for all tokens
 * @param contractAddress
 * @param options
 * @returns
 */
async function queryAllTokens(contractAddress, options) {
    const resp = await (0, client_1.query)(exports.QUERY_CW721_ALL_TOKENS, { contractAddress, options });
    return resp.cw721.allTokens;
}
exports.queryAllTokens = queryAllTokens;
exports.QUERY_CW721_APPROVAL = (0, graphql_request_1.gql) `
  query QUERY_CW721_APPROVAL(
    $contractAddress: String!
    $includeExpired: Boolean!
    $spender: String!
    $tokenId: String!
  ) {
    cw721(address: $contractAddress) {
      approval(
        includeExpired: $includeExpired
        spender: $spender
        tokenId: $tokenId
      ) {
        expires
        spender
      }
    }
  }
`;
/**
 * Queries a CW721 contract for whether a given address is an assigned operator for a given token
 * @param contractAddress
 * @param spender
 * @param tokenId
 * @param includeExpired
 * @returns
 */
async function queryApproval(contractAddress, spender, tokenId, includeExpired = false) {
    const resp = await (0, client_1.query)(exports.QUERY_CW721_APPROVAL, { contractAddress, spender, tokenId, includeExpired });
    return resp.cw721.approval;
}
exports.queryApproval = queryApproval;
exports.QUERY_CW721_APPROVALS = (0, graphql_request_1.gql) `
  query QUERY_CW721_APPROVALS(
    $contractAddress: String!
    $includeExpired: Boolean!
    $tokenId: String!
  ) {
    cw721(address: $contractAddress) {
      approvals(includeExpired: $includeExpired, tokenId: $tokenId) {
        spender
        expires
      }
    }
  }
`;
/**
 * Queries a CW721 contract for all approvals for a given token ID
 * @param contractAddress
 * @param tokenId
 * @param includeExpired
 * @returns
 */
async function queryApprovals(contractAddress, tokenId, includeExpired = false) {
    const resp = await (0, client_1.query)(exports.QUERY_CW721_APPROVALS, { contractAddress, tokenId, includeExpired });
    return resp.cw721.approvals;
}
exports.queryApprovals = queryApprovals;
exports.QUERY_CW721_CONTRACT_INFO = (0, graphql_request_1.gql) `
  query QUERY_CW721_CONTRACT_INFO($contractAddress: String!) {
    cw721(address: $contractAddress) {
      contractInfo {
        name
        symbol
      }
      minter
      numTokens
    }
  }
`;
/**
 * Queries a CW721 contract for its contract info
 * @param contractAddress
 * @returns
 */
async function queryContractInfo(contractAddress) {
    const resp = await (0, client_1.query)(exports.QUERY_CW721_CONTRACT_INFO, { contractAddress });
    return resp.cw721.contractInfo;
}
exports.queryContractInfo = queryContractInfo;
exports.QUERY_CW721_IS_ARCHIVED = (0, graphql_request_1.gql) `
  query QUERY_CW721_IS_ARCHIVED($contractAddress: String!, $tokenId: String!) {
    cw721(address: $contractAddress) {
      isArchived(tokenId: $tokenId)
    }
  }
`;
/**
 * Queries a CW721 contract whether a given token ID is archived
 * @param contractAddress
 * @param tokenId
 * @returns
 */
async function queryIsArchived(contractAddress, tokenId) {
    const resp = await (0, client_1.query)(exports.QUERY_CW721_IS_ARCHIVED, { contractAddress, tokenId });
    return resp.cw721.isArchived;
}
exports.queryIsArchived = queryIsArchived;
exports.QUERY_CW721_NFT_INFO = (0, graphql_request_1.gql) `
  query QUERY_CW721_NFT_INFO($contractAddress: String!, $tokenId: String!) {
    cw721(address: $contractAddress) {
      nftInfo(tokenId: $tokenId) {
        extension {
          ...TokenExtensionInfo
        }
        tokenUri
      }
    }
  }
  ${exports.TOKEN_EXTENSION_FRAGMENT}
`;
/**
 * Queries a CW721 contract for a given token IDs NFT info
 * @param contractAddress
 * @param tokenId
 * @returns
 */
async function queryNFTInfo(contractAddress, tokenId) {
    const resp = await (0, client_1.query)(exports.QUERY_CW721_NFT_INFO, { contractAddress, tokenId });
    return resp.cw721.nftInfo;
}
exports.queryNFTInfo = queryNFTInfo;
exports.QUERY_CW721_OWNER_OF = (0, graphql_request_1.gql) `
  query QUERY_CW721_OWNER_OF($contractAddress: String!, $tokenId: String!) {
    cw721(address: $contractAddress) {
      ownerOf(tokenId: $tokenId, includeExpired: false) {
        owner
      }
    }
  }
`;
/**
 * Queries a CW721 contract for the owner of a given token ID
 * @param contractAddress
 * @param tokenId
 * @returns
 */
async function queryOwnerOf(contractAddress, tokenId) {
    const resp = await (0, client_1.query)(exports.QUERY_CW721_OWNER_OF, { contractAddress, tokenId });
    return resp.cw721.ownerOf.owner;
}
exports.queryOwnerOf = queryOwnerOf;
exports.QUERY_CW721_TOKENS = (0, graphql_request_1.gql) `
  query QUERY_CW721_TOKENS(
    $contractAddress: String!
    $owner: String!
    $options: AndrSearchOptions
  ) {
    cw721(address: $contractAddress) {
      tokens(owner: $owner, options: $options)
    }
  }
`;
/**
 * Queries a CW721 contract for all tokens owned by a given address
 * @param contractAddress
 * @param owner
 * @param options
 * @returns
 */
async function queryTokens(contractAddress, owner, options) {
    const resp = await (0, client_1.query)(exports.QUERY_CW721_TOKENS, { contractAddress, owner, options });
    return resp.cw721.tokens;
}
exports.queryTokens = queryTokens;
exports.QUERY_CW721_TRANSFER_AGREEMENT = (0, graphql_request_1.gql) `
  query QUERY_CW721_TRANSFER_AGREEMENT(
    $contractAddress: String!
    $tokenId: String!
  ) {
    cw721(address: $contractAddress) {
      transferAgreement(tokenId: $tokenId) {
        agreement {
          amount {
            raw {
              amount
              denom
            }
          }
          purchaser
        }
        tokenId
      }
    }
  }
`;
/**
 * Queries a CW721 contract for the transfer agreement for a given token ID
 * @param contractAddress
 * @param tokenId
 * @returns
 */
async function queryTransferAgreement(contractAddress, tokenId) {
    const resp = await (0, client_1.query)(exports.QUERY_CW721_TRANSFER_AGREEMENT, { contractAddress, tokenId });
    return resp.cw721.transferAgreement;
}
exports.queryTransferAgreement = queryTransferAgreement;
