// package: injective_explorer_rpc
// file: injective_explorer_rpc.proto

import * as jspb from "google-protobuf";

export class GetAccountTxsRequest extends jspb.Message {
  getAddress(): string;
  setAddress(value: string): void;

  getBefore(): number;
  setBefore(value: number): void;

  getAfter(): number;
  setAfter(value: number): void;

  getLimit(): number;
  setLimit(value: number): void;

  getSkip(): number;
  setSkip(value: number): void;

  getType(): string;
  setType(value: string): void;

  getModule(): string;
  setModule(value: string): void;

  getFromNumber(): number;
  setFromNumber(value: number): void;

  getToNumber(): number;
  setToNumber(value: number): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): GetAccountTxsRequest.AsObject;
  static toObject(includeInstance: boolean, msg: GetAccountTxsRequest): GetAccountTxsRequest.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: GetAccountTxsRequest, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): GetAccountTxsRequest;
  static deserializeBinaryFromReader(message: GetAccountTxsRequest, reader: jspb.BinaryReader): GetAccountTxsRequest;
}

export namespace GetAccountTxsRequest {
  export type AsObject = {
    address: string,
    before: number,
    after: number,
    limit: number,
    skip: number,
    type: string,
    module: string,
    fromNumber: number,
    toNumber: number,
  }
}

export class GetAccountTxsResponse extends jspb.Message {
  hasPaging(): boolean;
  clearPaging(): void;
  getPaging(): Paging | undefined;
  setPaging(value?: Paging): void;

  clearDataList(): void;
  getDataList(): Array<TxDetailData>;
  setDataList(value: Array<TxDetailData>): void;
  addData(value?: TxDetailData, index?: number): TxDetailData;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): GetAccountTxsResponse.AsObject;
  static toObject(includeInstance: boolean, msg: GetAccountTxsResponse): GetAccountTxsResponse.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: GetAccountTxsResponse, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): GetAccountTxsResponse;
  static deserializeBinaryFromReader(message: GetAccountTxsResponse, reader: jspb.BinaryReader): GetAccountTxsResponse;
}

export namespace GetAccountTxsResponse {
  export type AsObject = {
    paging?: Paging.AsObject,
    dataList: Array<TxDetailData.AsObject>,
  }
}

export class Paging extends jspb.Message {
  getTotal(): number;
  setTotal(value: number): void;

  getFrom(): number;
  setFrom(value: number): void;

  getTo(): number;
  setTo(value: number): void;

  getCountBySubaccount(): number;
  setCountBySubaccount(value: number): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): Paging.AsObject;
  static toObject(includeInstance: boolean, msg: Paging): Paging.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: Paging, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): Paging;
  static deserializeBinaryFromReader(message: Paging, reader: jspb.BinaryReader): Paging;
}

export namespace Paging {
  export type AsObject = {
    total: number,
    from: number,
    to: number,
    countBySubaccount: number,
  }
}

export class TxDetailData extends jspb.Message {
  getId(): string;
  setId(value: string): void;

  getBlockNumber(): number;
  setBlockNumber(value: number): void;

  getBlockTimestamp(): string;
  setBlockTimestamp(value: string): void;

  getHash(): string;
  setHash(value: string): void;

  getCode(): number;
  setCode(value: number): void;

  getData(): Uint8Array | string;
  getData_asU8(): Uint8Array;
  getData_asB64(): string;
  setData(value: Uint8Array | string): void;

  getInfo(): string;
  setInfo(value: string): void;

  getGasWanted(): number;
  setGasWanted(value: number): void;

  getGasUsed(): number;
  setGasUsed(value: number): void;

  hasGasFee(): boolean;
  clearGasFee(): void;
  getGasFee(): GasFee | undefined;
  setGasFee(value?: GasFee): void;

  getCodespace(): string;
  setCodespace(value: string): void;

  clearEventsList(): void;
  getEventsList(): Array<Event>;
  setEventsList(value: Array<Event>): void;
  addEvents(value?: Event, index?: number): Event;

  getTxType(): string;
  setTxType(value: string): void;

  getMessages(): Uint8Array | string;
  getMessages_asU8(): Uint8Array;
  getMessages_asB64(): string;
  setMessages(value: Uint8Array | string): void;

  clearSignaturesList(): void;
  getSignaturesList(): Array<Signature>;
  setSignaturesList(value: Array<Signature>): void;
  addSignatures(value?: Signature, index?: number): Signature;

  getMemo(): string;
  setMemo(value: string): void;

  getTxNumber(): number;
  setTxNumber(value: number): void;

  getBlockUnixTimestamp(): number;
  setBlockUnixTimestamp(value: number): void;

  getErrorLog(): string;
  setErrorLog(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): TxDetailData.AsObject;
  static toObject(includeInstance: boolean, msg: TxDetailData): TxDetailData.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: TxDetailData, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): TxDetailData;
  static deserializeBinaryFromReader(message: TxDetailData, reader: jspb.BinaryReader): TxDetailData;
}

export namespace TxDetailData {
  export type AsObject = {
    id: string,
    blockNumber: number,
    blockTimestamp: string,
    hash: string,
    code: number,
    data: Uint8Array | string,
    info: string,
    gasWanted: number,
    gasUsed: number,
    gasFee?: GasFee.AsObject,
    codespace: string,
    eventsList: Array<Event.AsObject>,
    txType: string,
    messages: Uint8Array | string,
    signaturesList: Array<Signature.AsObject>,
    memo: string,
    txNumber: number,
    blockUnixTimestamp: number,
    errorLog: string,
  }
}

export class GasFee extends jspb.Message {
  clearAmountList(): void;
  getAmountList(): Array<CosmosCoin>;
  setAmountList(value: Array<CosmosCoin>): void;
  addAmount(value?: CosmosCoin, index?: number): CosmosCoin;

  getGasLimit(): number;
  setGasLimit(value: number): void;

  getPayer(): string;
  setPayer(value: string): void;

  getGranter(): string;
  setGranter(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): GasFee.AsObject;
  static toObject(includeInstance: boolean, msg: GasFee): GasFee.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: GasFee, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): GasFee;
  static deserializeBinaryFromReader(message: GasFee, reader: jspb.BinaryReader): GasFee;
}

export namespace GasFee {
  export type AsObject = {
    amountList: Array<CosmosCoin.AsObject>,
    gasLimit: number,
    payer: string,
    granter: string,
  }
}

export class CosmosCoin extends jspb.Message {
  getDenom(): string;
  setDenom(value: string): void;

  getAmount(): string;
  setAmount(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): CosmosCoin.AsObject;
  static toObject(includeInstance: boolean, msg: CosmosCoin): CosmosCoin.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: CosmosCoin, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): CosmosCoin;
  static deserializeBinaryFromReader(message: CosmosCoin, reader: jspb.BinaryReader): CosmosCoin;
}

export namespace CosmosCoin {
  export type AsObject = {
    denom: string,
    amount: string,
  }
}

export class Event extends jspb.Message {
  getType(): string;
  setType(value: string): void;

  getAttributesMap(): jspb.Map<string, string>;
  clearAttributesMap(): void;
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): Event.AsObject;
  static toObject(includeInstance: boolean, msg: Event): Event.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: Event, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): Event;
  static deserializeBinaryFromReader(message: Event, reader: jspb.BinaryReader): Event;
}

export namespace Event {
  export type AsObject = {
    type: string,
    attributesMap: Array<[string, string]>,
  }
}

export class Signature extends jspb.Message {
  getPubkey(): string;
  setPubkey(value: string): void;

  getAddress(): string;
  setAddress(value: string): void;

  getSequence(): number;
  setSequence(value: number): void;

  getSignature(): string;
  setSignature(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): Signature.AsObject;
  static toObject(includeInstance: boolean, msg: Signature): Signature.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: Signature, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): Signature;
  static deserializeBinaryFromReader(message: Signature, reader: jspb.BinaryReader): Signature;
}

export namespace Signature {
  export type AsObject = {
    pubkey: string,
    address: string,
    sequence: number,
    signature: string,
  }
}

export class GetContractTxsRequest extends jspb.Message {
  getAddress(): string;
  setAddress(value: string): void;

  getLimit(): number;
  setLimit(value: number): void;

  getSkip(): number;
  setSkip(value: number): void;

  getFromNumber(): number;
  setFromNumber(value: number): void;

  getToNumber(): number;
  setToNumber(value: number): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): GetContractTxsRequest.AsObject;
  static toObject(includeInstance: boolean, msg: GetContractTxsRequest): GetContractTxsRequest.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: GetContractTxsRequest, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): GetContractTxsRequest;
  static deserializeBinaryFromReader(message: GetContractTxsRequest, reader: jspb.BinaryReader): GetContractTxsRequest;
}

export namespace GetContractTxsRequest {
  export type AsObject = {
    address: string,
    limit: number,
    skip: number,
    fromNumber: number,
    toNumber: number,
  }
}

export class GetContractTxsResponse extends jspb.Message {
  hasPaging(): boolean;
  clearPaging(): void;
  getPaging(): Paging | undefined;
  setPaging(value?: Paging): void;

  clearDataList(): void;
  getDataList(): Array<TxDetailData>;
  setDataList(value: Array<TxDetailData>): void;
  addData(value?: TxDetailData, index?: number): TxDetailData;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): GetContractTxsResponse.AsObject;
  static toObject(includeInstance: boolean, msg: GetContractTxsResponse): GetContractTxsResponse.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: GetContractTxsResponse, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): GetContractTxsResponse;
  static deserializeBinaryFromReader(message: GetContractTxsResponse, reader: jspb.BinaryReader): GetContractTxsResponse;
}

export namespace GetContractTxsResponse {
  export type AsObject = {
    paging?: Paging.AsObject,
    dataList: Array<TxDetailData.AsObject>,
  }
}

export class GetBlocksRequest extends jspb.Message {
  getBefore(): number;
  setBefore(value: number): void;

  getAfter(): number;
  setAfter(value: number): void;

  getLimit(): number;
  setLimit(value: number): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): GetBlocksRequest.AsObject;
  static toObject(includeInstance: boolean, msg: GetBlocksRequest): GetBlocksRequest.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: GetBlocksRequest, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): GetBlocksRequest;
  static deserializeBinaryFromReader(message: GetBlocksRequest, reader: jspb.BinaryReader): GetBlocksRequest;
}

export namespace GetBlocksRequest {
  export type AsObject = {
    before: number,
    after: number,
    limit: number,
  }
}

export class GetBlocksResponse extends jspb.Message {
  hasPaging(): boolean;
  clearPaging(): void;
  getPaging(): Paging | undefined;
  setPaging(value?: Paging): void;

  clearDataList(): void;
  getDataList(): Array<BlockInfo>;
  setDataList(value: Array<BlockInfo>): void;
  addData(value?: BlockInfo, index?: number): BlockInfo;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): GetBlocksResponse.AsObject;
  static toObject(includeInstance: boolean, msg: GetBlocksResponse): GetBlocksResponse.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: GetBlocksResponse, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): GetBlocksResponse;
  static deserializeBinaryFromReader(message: GetBlocksResponse, reader: jspb.BinaryReader): GetBlocksResponse;
}

export namespace GetBlocksResponse {
  export type AsObject = {
    paging?: Paging.AsObject,
    dataList: Array<BlockInfo.AsObject>,
  }
}

export class BlockInfo extends jspb.Message {
  getHeight(): number;
  setHeight(value: number): void;

  getProposer(): string;
  setProposer(value: string): void;

  getMoniker(): string;
  setMoniker(value: string): void;

  getBlockHash(): string;
  setBlockHash(value: string): void;

  getParentHash(): string;
  setParentHash(value: string): void;

  getNumPreCommits(): number;
  setNumPreCommits(value: number): void;

  getNumTxs(): number;
  setNumTxs(value: number): void;

  clearTxsList(): void;
  getTxsList(): Array<TxDataRPC>;
  setTxsList(value: Array<TxDataRPC>): void;
  addTxs(value?: TxDataRPC, index?: number): TxDataRPC;

  getTimestamp(): string;
  setTimestamp(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): BlockInfo.AsObject;
  static toObject(includeInstance: boolean, msg: BlockInfo): BlockInfo.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: BlockInfo, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): BlockInfo;
  static deserializeBinaryFromReader(message: BlockInfo, reader: jspb.BinaryReader): BlockInfo;
}

export namespace BlockInfo {
  export type AsObject = {
    height: number,
    proposer: string,
    moniker: string,
    blockHash: string,
    parentHash: string,
    numPreCommits: number,
    numTxs: number,
    txsList: Array<TxDataRPC.AsObject>,
    timestamp: string,
  }
}

export class TxDataRPC extends jspb.Message {
  getId(): string;
  setId(value: string): void;

  getBlockNumber(): number;
  setBlockNumber(value: number): void;

  getBlockTimestamp(): string;
  setBlockTimestamp(value: string): void;

  getHash(): string;
  setHash(value: string): void;

  getCodespace(): string;
  setCodespace(value: string): void;

  getMessages(): string;
  setMessages(value: string): void;

  getTxNumber(): number;
  setTxNumber(value: number): void;

  getErrorLog(): string;
  setErrorLog(value: string): void;

  getCode(): number;
  setCode(value: number): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): TxDataRPC.AsObject;
  static toObject(includeInstance: boolean, msg: TxDataRPC): TxDataRPC.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: TxDataRPC, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): TxDataRPC;
  static deserializeBinaryFromReader(message: TxDataRPC, reader: jspb.BinaryReader): TxDataRPC;
}

export namespace TxDataRPC {
  export type AsObject = {
    id: string,
    blockNumber: number,
    blockTimestamp: string,
    hash: string,
    codespace: string,
    messages: string,
    txNumber: number,
    errorLog: string,
    code: number,
  }
}

export class GetBlockRequest extends jspb.Message {
  getId(): string;
  setId(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): GetBlockRequest.AsObject;
  static toObject(includeInstance: boolean, msg: GetBlockRequest): GetBlockRequest.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: GetBlockRequest, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): GetBlockRequest;
  static deserializeBinaryFromReader(message: GetBlockRequest, reader: jspb.BinaryReader): GetBlockRequest;
}

export namespace GetBlockRequest {
  export type AsObject = {
    id: string,
  }
}

export class GetBlockResponse extends jspb.Message {
  getS(): string;
  setS(value: string): void;

  getErrmsg(): string;
  setErrmsg(value: string): void;

  hasData(): boolean;
  clearData(): void;
  getData(): BlockDetailInfo | undefined;
  setData(value?: BlockDetailInfo): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): GetBlockResponse.AsObject;
  static toObject(includeInstance: boolean, msg: GetBlockResponse): GetBlockResponse.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: GetBlockResponse, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): GetBlockResponse;
  static deserializeBinaryFromReader(message: GetBlockResponse, reader: jspb.BinaryReader): GetBlockResponse;
}

export namespace GetBlockResponse {
  export type AsObject = {
    s: string,
    errmsg: string,
    data?: BlockDetailInfo.AsObject,
  }
}

export class BlockDetailInfo extends jspb.Message {
  getHeight(): number;
  setHeight(value: number): void;

  getProposer(): string;
  setProposer(value: string): void;

  getMoniker(): string;
  setMoniker(value: string): void;

  getBlockHash(): string;
  setBlockHash(value: string): void;

  getParentHash(): string;
  setParentHash(value: string): void;

  getNumPreCommits(): number;
  setNumPreCommits(value: number): void;

  getNumTxs(): number;
  setNumTxs(value: number): void;

  getTotalTxs(): number;
  setTotalTxs(value: number): void;

  clearTxsList(): void;
  getTxsList(): Array<TxData>;
  setTxsList(value: Array<TxData>): void;
  addTxs(value?: TxData, index?: number): TxData;

  getTimestamp(): string;
  setTimestamp(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): BlockDetailInfo.AsObject;
  static toObject(includeInstance: boolean, msg: BlockDetailInfo): BlockDetailInfo.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: BlockDetailInfo, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): BlockDetailInfo;
  static deserializeBinaryFromReader(message: BlockDetailInfo, reader: jspb.BinaryReader): BlockDetailInfo;
}

export namespace BlockDetailInfo {
  export type AsObject = {
    height: number,
    proposer: string,
    moniker: string,
    blockHash: string,
    parentHash: string,
    numPreCommits: number,
    numTxs: number,
    totalTxs: number,
    txsList: Array<TxData.AsObject>,
    timestamp: string,
  }
}

export class TxData extends jspb.Message {
  getId(): string;
  setId(value: string): void;

  getBlockNumber(): number;
  setBlockNumber(value: number): void;

  getBlockTimestamp(): string;
  setBlockTimestamp(value: string): void;

  getHash(): string;
  setHash(value: string): void;

  getCodespace(): string;
  setCodespace(value: string): void;

  getMessages(): Uint8Array | string;
  getMessages_asU8(): Uint8Array;
  getMessages_asB64(): string;
  setMessages(value: Uint8Array | string): void;

  getTxNumber(): number;
  setTxNumber(value: number): void;

  getErrorLog(): string;
  setErrorLog(value: string): void;

  getCode(): number;
  setCode(value: number): void;

  getTxMsgTypes(): Uint8Array | string;
  getTxMsgTypes_asU8(): Uint8Array;
  getTxMsgTypes_asB64(): string;
  setTxMsgTypes(value: Uint8Array | string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): TxData.AsObject;
  static toObject(includeInstance: boolean, msg: TxData): TxData.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: TxData, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): TxData;
  static deserializeBinaryFromReader(message: TxData, reader: jspb.BinaryReader): TxData;
}

export namespace TxData {
  export type AsObject = {
    id: string,
    blockNumber: number,
    blockTimestamp: string,
    hash: string,
    codespace: string,
    messages: Uint8Array | string,
    txNumber: number,
    errorLog: string,
    code: number,
    txMsgTypes: Uint8Array | string,
  }
}

export class GetValidatorsRequest extends jspb.Message {
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): GetValidatorsRequest.AsObject;
  static toObject(includeInstance: boolean, msg: GetValidatorsRequest): GetValidatorsRequest.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: GetValidatorsRequest, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): GetValidatorsRequest;
  static deserializeBinaryFromReader(message: GetValidatorsRequest, reader: jspb.BinaryReader): GetValidatorsRequest;
}

export namespace GetValidatorsRequest {
  export type AsObject = {
  }
}

export class GetValidatorsResponse extends jspb.Message {
  getS(): string;
  setS(value: string): void;

  getErrmsg(): string;
  setErrmsg(value: string): void;

  clearDataList(): void;
  getDataList(): Array<Validator>;
  setDataList(value: Array<Validator>): void;
  addData(value?: Validator, index?: number): Validator;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): GetValidatorsResponse.AsObject;
  static toObject(includeInstance: boolean, msg: GetValidatorsResponse): GetValidatorsResponse.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: GetValidatorsResponse, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): GetValidatorsResponse;
  static deserializeBinaryFromReader(message: GetValidatorsResponse, reader: jspb.BinaryReader): GetValidatorsResponse;
}

export namespace GetValidatorsResponse {
  export type AsObject = {
    s: string,
    errmsg: string,
    dataList: Array<Validator.AsObject>,
  }
}

export class Validator extends jspb.Message {
  getId(): string;
  setId(value: string): void;

  getMoniker(): string;
  setMoniker(value: string): void;

  getOperatorAddress(): string;
  setOperatorAddress(value: string): void;

  getConsensusAddress(): string;
  setConsensusAddress(value: string): void;

  getJailed(): boolean;
  setJailed(value: boolean): void;

  getStatus(): number;
  setStatus(value: number): void;

  getTokens(): string;
  setTokens(value: string): void;

  getDelegatorShares(): string;
  setDelegatorShares(value: string): void;

  hasDescription(): boolean;
  clearDescription(): void;
  getDescription(): ValidatorDescription | undefined;
  setDescription(value?: ValidatorDescription): void;

  getUnbondingHeight(): number;
  setUnbondingHeight(value: number): void;

  getUnbondingTime(): string;
  setUnbondingTime(value: string): void;

  getCommissionRate(): string;
  setCommissionRate(value: string): void;

  getCommissionMaxRate(): string;
  setCommissionMaxRate(value: string): void;

  getCommissionMaxChangeRate(): string;
  setCommissionMaxChangeRate(value: string): void;

  getCommissionUpdateTime(): string;
  setCommissionUpdateTime(value: string): void;

  getProposed(): number;
  setProposed(value: number): void;

  getSigned(): number;
  setSigned(value: number): void;

  getMissed(): number;
  setMissed(value: number): void;

  getTimestamp(): string;
  setTimestamp(value: string): void;

  clearUptimesList(): void;
  getUptimesList(): Array<ValidatorUptime>;
  setUptimesList(value: Array<ValidatorUptime>): void;
  addUptimes(value?: ValidatorUptime, index?: number): ValidatorUptime;

  clearSlashingEventsList(): void;
  getSlashingEventsList(): Array<SlashingEvent>;
  setSlashingEventsList(value: Array<SlashingEvent>): void;
  addSlashingEvents(value?: SlashingEvent, index?: number): SlashingEvent;

  getUptimePercentage(): number;
  setUptimePercentage(value: number): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): Validator.AsObject;
  static toObject(includeInstance: boolean, msg: Validator): Validator.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: Validator, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): Validator;
  static deserializeBinaryFromReader(message: Validator, reader: jspb.BinaryReader): Validator;
}

export namespace Validator {
  export type AsObject = {
    id: string,
    moniker: string,
    operatorAddress: string,
    consensusAddress: string,
    jailed: boolean,
    status: number,
    tokens: string,
    delegatorShares: string,
    description?: ValidatorDescription.AsObject,
    unbondingHeight: number,
    unbondingTime: string,
    commissionRate: string,
    commissionMaxRate: string,
    commissionMaxChangeRate: string,
    commissionUpdateTime: string,
    proposed: number,
    signed: number,
    missed: number,
    timestamp: string,
    uptimesList: Array<ValidatorUptime.AsObject>,
    slashingEventsList: Array<SlashingEvent.AsObject>,
    uptimePercentage: number,
  }
}

export class ValidatorDescription extends jspb.Message {
  getMoniker(): string;
  setMoniker(value: string): void;

  getIdentity(): string;
  setIdentity(value: string): void;

  getWebsite(): string;
  setWebsite(value: string): void;

  getSecurityContact(): string;
  setSecurityContact(value: string): void;

  getDetails(): string;
  setDetails(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): ValidatorDescription.AsObject;
  static toObject(includeInstance: boolean, msg: ValidatorDescription): ValidatorDescription.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: ValidatorDescription, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): ValidatorDescription;
  static deserializeBinaryFromReader(message: ValidatorDescription, reader: jspb.BinaryReader): ValidatorDescription;
}

export namespace ValidatorDescription {
  export type AsObject = {
    moniker: string,
    identity: string,
    website: string,
    securityContact: string,
    details: string,
  }
}

export class ValidatorUptime extends jspb.Message {
  getBlockNumber(): number;
  setBlockNumber(value: number): void;

  getStatus(): string;
  setStatus(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): ValidatorUptime.AsObject;
  static toObject(includeInstance: boolean, msg: ValidatorUptime): ValidatorUptime.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: ValidatorUptime, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): ValidatorUptime;
  static deserializeBinaryFromReader(message: ValidatorUptime, reader: jspb.BinaryReader): ValidatorUptime;
}

export namespace ValidatorUptime {
  export type AsObject = {
    blockNumber: number,
    status: string,
  }
}

export class SlashingEvent extends jspb.Message {
  getBlockNumber(): number;
  setBlockNumber(value: number): void;

  getBlockTimestamp(): string;
  setBlockTimestamp(value: string): void;

  getAddress(): string;
  setAddress(value: string): void;

  getPower(): number;
  setPower(value: number): void;

  getReason(): string;
  setReason(value: string): void;

  getJailed(): string;
  setJailed(value: string): void;

  getMissedBlocks(): number;
  setMissedBlocks(value: number): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): SlashingEvent.AsObject;
  static toObject(includeInstance: boolean, msg: SlashingEvent): SlashingEvent.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: SlashingEvent, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): SlashingEvent;
  static deserializeBinaryFromReader(message: SlashingEvent, reader: jspb.BinaryReader): SlashingEvent;
}

export namespace SlashingEvent {
  export type AsObject = {
    blockNumber: number,
    blockTimestamp: string,
    address: string,
    power: number,
    reason: string,
    jailed: string,
    missedBlocks: number,
  }
}

export class GetValidatorRequest extends jspb.Message {
  getAddress(): string;
  setAddress(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): GetValidatorRequest.AsObject;
  static toObject(includeInstance: boolean, msg: GetValidatorRequest): GetValidatorRequest.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: GetValidatorRequest, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): GetValidatorRequest;
  static deserializeBinaryFromReader(message: GetValidatorRequest, reader: jspb.BinaryReader): GetValidatorRequest;
}

export namespace GetValidatorRequest {
  export type AsObject = {
    address: string,
  }
}

export class GetValidatorResponse extends jspb.Message {
  getS(): string;
  setS(value: string): void;

  getErrmsg(): string;
  setErrmsg(value: string): void;

  hasData(): boolean;
  clearData(): void;
  getData(): Validator | undefined;
  setData(value?: Validator): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): GetValidatorResponse.AsObject;
  static toObject(includeInstance: boolean, msg: GetValidatorResponse): GetValidatorResponse.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: GetValidatorResponse, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): GetValidatorResponse;
  static deserializeBinaryFromReader(message: GetValidatorResponse, reader: jspb.BinaryReader): GetValidatorResponse;
}

export namespace GetValidatorResponse {
  export type AsObject = {
    s: string,
    errmsg: string,
    data?: Validator.AsObject,
  }
}

export class GetValidatorUptimeRequest extends jspb.Message {
  getAddress(): string;
  setAddress(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): GetValidatorUptimeRequest.AsObject;
  static toObject(includeInstance: boolean, msg: GetValidatorUptimeRequest): GetValidatorUptimeRequest.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: GetValidatorUptimeRequest, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): GetValidatorUptimeRequest;
  static deserializeBinaryFromReader(message: GetValidatorUptimeRequest, reader: jspb.BinaryReader): GetValidatorUptimeRequest;
}

export namespace GetValidatorUptimeRequest {
  export type AsObject = {
    address: string,
  }
}

export class GetValidatorUptimeResponse extends jspb.Message {
  getS(): string;
  setS(value: string): void;

  getErrmsg(): string;
  setErrmsg(value: string): void;

  clearDataList(): void;
  getDataList(): Array<ValidatorUptime>;
  setDataList(value: Array<ValidatorUptime>): void;
  addData(value?: ValidatorUptime, index?: number): ValidatorUptime;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): GetValidatorUptimeResponse.AsObject;
  static toObject(includeInstance: boolean, msg: GetValidatorUptimeResponse): GetValidatorUptimeResponse.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: GetValidatorUptimeResponse, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): GetValidatorUptimeResponse;
  static deserializeBinaryFromReader(message: GetValidatorUptimeResponse, reader: jspb.BinaryReader): GetValidatorUptimeResponse;
}

export namespace GetValidatorUptimeResponse {
  export type AsObject = {
    s: string,
    errmsg: string,
    dataList: Array<ValidatorUptime.AsObject>,
  }
}

export class GetTxsRequest extends jspb.Message {
  getBefore(): number;
  setBefore(value: number): void;

  getAfter(): number;
  setAfter(value: number): void;

  getLimit(): number;
  setLimit(value: number): void;

  getSkip(): number;
  setSkip(value: number): void;

  getType(): string;
  setType(value: string): void;

  getModule(): string;
  setModule(value: string): void;

  getFromNumber(): number;
  setFromNumber(value: number): void;

  getToNumber(): number;
  setToNumber(value: number): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): GetTxsRequest.AsObject;
  static toObject(includeInstance: boolean, msg: GetTxsRequest): GetTxsRequest.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: GetTxsRequest, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): GetTxsRequest;
  static deserializeBinaryFromReader(message: GetTxsRequest, reader: jspb.BinaryReader): GetTxsRequest;
}

export namespace GetTxsRequest {
  export type AsObject = {
    before: number,
    after: number,
    limit: number,
    skip: number,
    type: string,
    module: string,
    fromNumber: number,
    toNumber: number,
  }
}

export class GetTxsResponse extends jspb.Message {
  hasPaging(): boolean;
  clearPaging(): void;
  getPaging(): Paging | undefined;
  setPaging(value?: Paging): void;

  clearDataList(): void;
  getDataList(): Array<TxData>;
  setDataList(value: Array<TxData>): void;
  addData(value?: TxData, index?: number): TxData;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): GetTxsResponse.AsObject;
  static toObject(includeInstance: boolean, msg: GetTxsResponse): GetTxsResponse.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: GetTxsResponse, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): GetTxsResponse;
  static deserializeBinaryFromReader(message: GetTxsResponse, reader: jspb.BinaryReader): GetTxsResponse;
}

export namespace GetTxsResponse {
  export type AsObject = {
    paging?: Paging.AsObject,
    dataList: Array<TxData.AsObject>,
  }
}

export class GetTxByTxHashRequest extends jspb.Message {
  getHash(): string;
  setHash(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): GetTxByTxHashRequest.AsObject;
  static toObject(includeInstance: boolean, msg: GetTxByTxHashRequest): GetTxByTxHashRequest.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: GetTxByTxHashRequest, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): GetTxByTxHashRequest;
  static deserializeBinaryFromReader(message: GetTxByTxHashRequest, reader: jspb.BinaryReader): GetTxByTxHashRequest;
}

export namespace GetTxByTxHashRequest {
  export type AsObject = {
    hash: string,
  }
}

export class GetTxByTxHashResponse extends jspb.Message {
  getS(): string;
  setS(value: string): void;

  getErrmsg(): string;
  setErrmsg(value: string): void;

  hasData(): boolean;
  clearData(): void;
  getData(): TxDetailData | undefined;
  setData(value?: TxDetailData): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): GetTxByTxHashResponse.AsObject;
  static toObject(includeInstance: boolean, msg: GetTxByTxHashResponse): GetTxByTxHashResponse.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: GetTxByTxHashResponse, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): GetTxByTxHashResponse;
  static deserializeBinaryFromReader(message: GetTxByTxHashResponse, reader: jspb.BinaryReader): GetTxByTxHashResponse;
}

export namespace GetTxByTxHashResponse {
  export type AsObject = {
    s: string,
    errmsg: string,
    data?: TxDetailData.AsObject,
  }
}

export class GetPeggyDepositTxsRequest extends jspb.Message {
  getSender(): string;
  setSender(value: string): void;

  getReceiver(): string;
  setReceiver(value: string): void;

  getLimit(): number;
  setLimit(value: number): void;

  getSkip(): number;
  setSkip(value: number): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): GetPeggyDepositTxsRequest.AsObject;
  static toObject(includeInstance: boolean, msg: GetPeggyDepositTxsRequest): GetPeggyDepositTxsRequest.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: GetPeggyDepositTxsRequest, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): GetPeggyDepositTxsRequest;
  static deserializeBinaryFromReader(message: GetPeggyDepositTxsRequest, reader: jspb.BinaryReader): GetPeggyDepositTxsRequest;
}

export namespace GetPeggyDepositTxsRequest {
  export type AsObject = {
    sender: string,
    receiver: string,
    limit: number,
    skip: number,
  }
}

export class GetPeggyDepositTxsResponse extends jspb.Message {
  clearFieldList(): void;
  getFieldList(): Array<PeggyDepositTx>;
  setFieldList(value: Array<PeggyDepositTx>): void;
  addField(value?: PeggyDepositTx, index?: number): PeggyDepositTx;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): GetPeggyDepositTxsResponse.AsObject;
  static toObject(includeInstance: boolean, msg: GetPeggyDepositTxsResponse): GetPeggyDepositTxsResponse.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: GetPeggyDepositTxsResponse, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): GetPeggyDepositTxsResponse;
  static deserializeBinaryFromReader(message: GetPeggyDepositTxsResponse, reader: jspb.BinaryReader): GetPeggyDepositTxsResponse;
}

export namespace GetPeggyDepositTxsResponse {
  export type AsObject = {
    fieldList: Array<PeggyDepositTx.AsObject>,
  }
}

export class PeggyDepositTx extends jspb.Message {
  getSender(): string;
  setSender(value: string): void;

  getReceiver(): string;
  setReceiver(value: string): void;

  getEventNonce(): number;
  setEventNonce(value: number): void;

  getEventHeight(): number;
  setEventHeight(value: number): void;

  getAmount(): string;
  setAmount(value: string): void;

  getDenom(): string;
  setDenom(value: string): void;

  getOrchestratorAddress(): string;
  setOrchestratorAddress(value: string): void;

  getState(): string;
  setState(value: string): void;

  getClaimType(): number;
  setClaimType(value: number): void;

  clearTxHashesList(): void;
  getTxHashesList(): Array<string>;
  setTxHashesList(value: Array<string>): void;
  addTxHashes(value: string, index?: number): string;

  getCreatedAt(): string;
  setCreatedAt(value: string): void;

  getUpdatedAt(): string;
  setUpdatedAt(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): PeggyDepositTx.AsObject;
  static toObject(includeInstance: boolean, msg: PeggyDepositTx): PeggyDepositTx.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: PeggyDepositTx, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): PeggyDepositTx;
  static deserializeBinaryFromReader(message: PeggyDepositTx, reader: jspb.BinaryReader): PeggyDepositTx;
}

export namespace PeggyDepositTx {
  export type AsObject = {
    sender: string,
    receiver: string,
    eventNonce: number,
    eventHeight: number,
    amount: string,
    denom: string,
    orchestratorAddress: string,
    state: string,
    claimType: number,
    txHashesList: Array<string>,
    createdAt: string,
    updatedAt: string,
  }
}

export class GetPeggyWithdrawalTxsRequest extends jspb.Message {
  getSender(): string;
  setSender(value: string): void;

  getReceiver(): string;
  setReceiver(value: string): void;

  getLimit(): number;
  setLimit(value: number): void;

  getSkip(): number;
  setSkip(value: number): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): GetPeggyWithdrawalTxsRequest.AsObject;
  static toObject(includeInstance: boolean, msg: GetPeggyWithdrawalTxsRequest): GetPeggyWithdrawalTxsRequest.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: GetPeggyWithdrawalTxsRequest, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): GetPeggyWithdrawalTxsRequest;
  static deserializeBinaryFromReader(message: GetPeggyWithdrawalTxsRequest, reader: jspb.BinaryReader): GetPeggyWithdrawalTxsRequest;
}

export namespace GetPeggyWithdrawalTxsRequest {
  export type AsObject = {
    sender: string,
    receiver: string,
    limit: number,
    skip: number,
  }
}

export class GetPeggyWithdrawalTxsResponse extends jspb.Message {
  clearFieldList(): void;
  getFieldList(): Array<PeggyWithdrawalTx>;
  setFieldList(value: Array<PeggyWithdrawalTx>): void;
  addField(value?: PeggyWithdrawalTx, index?: number): PeggyWithdrawalTx;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): GetPeggyWithdrawalTxsResponse.AsObject;
  static toObject(includeInstance: boolean, msg: GetPeggyWithdrawalTxsResponse): GetPeggyWithdrawalTxsResponse.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: GetPeggyWithdrawalTxsResponse, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): GetPeggyWithdrawalTxsResponse;
  static deserializeBinaryFromReader(message: GetPeggyWithdrawalTxsResponse, reader: jspb.BinaryReader): GetPeggyWithdrawalTxsResponse;
}

export namespace GetPeggyWithdrawalTxsResponse {
  export type AsObject = {
    fieldList: Array<PeggyWithdrawalTx.AsObject>,
  }
}

export class PeggyWithdrawalTx extends jspb.Message {
  getSender(): string;
  setSender(value: string): void;

  getReceiver(): string;
  setReceiver(value: string): void;

  getAmount(): string;
  setAmount(value: string): void;

  getDenom(): string;
  setDenom(value: string): void;

  getBridgeFee(): string;
  setBridgeFee(value: string): void;

  getOutgoingTxId(): number;
  setOutgoingTxId(value: number): void;

  getBatchTimeout(): number;
  setBatchTimeout(value: number): void;

  getBatchNonce(): number;
  setBatchNonce(value: number): void;

  getOrchestratorAddress(): string;
  setOrchestratorAddress(value: string): void;

  getEventNonce(): number;
  setEventNonce(value: number): void;

  getEventHeight(): number;
  setEventHeight(value: number): void;

  getState(): string;
  setState(value: string): void;

  getClaimType(): number;
  setClaimType(value: number): void;

  clearTxHashesList(): void;
  getTxHashesList(): Array<string>;
  setTxHashesList(value: Array<string>): void;
  addTxHashes(value: string, index?: number): string;

  getCreatedAt(): string;
  setCreatedAt(value: string): void;

  getUpdatedAt(): string;
  setUpdatedAt(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): PeggyWithdrawalTx.AsObject;
  static toObject(includeInstance: boolean, msg: PeggyWithdrawalTx): PeggyWithdrawalTx.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: PeggyWithdrawalTx, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): PeggyWithdrawalTx;
  static deserializeBinaryFromReader(message: PeggyWithdrawalTx, reader: jspb.BinaryReader): PeggyWithdrawalTx;
}

export namespace PeggyWithdrawalTx {
  export type AsObject = {
    sender: string,
    receiver: string,
    amount: string,
    denom: string,
    bridgeFee: string,
    outgoingTxId: number,
    batchTimeout: number,
    batchNonce: number,
    orchestratorAddress: string,
    eventNonce: number,
    eventHeight: number,
    state: string,
    claimType: number,
    txHashesList: Array<string>,
    createdAt: string,
    updatedAt: string,
  }
}

export class GetIBCTransferTxsRequest extends jspb.Message {
  getSender(): string;
  setSender(value: string): void;

  getReceiver(): string;
  setReceiver(value: string): void;

  getSrcChannel(): string;
  setSrcChannel(value: string): void;

  getSrcPort(): string;
  setSrcPort(value: string): void;

  getDestChannel(): string;
  setDestChannel(value: string): void;

  getDestPort(): string;
  setDestPort(value: string): void;

  getLimit(): number;
  setLimit(value: number): void;

  getSkip(): number;
  setSkip(value: number): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): GetIBCTransferTxsRequest.AsObject;
  static toObject(includeInstance: boolean, msg: GetIBCTransferTxsRequest): GetIBCTransferTxsRequest.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: GetIBCTransferTxsRequest, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): GetIBCTransferTxsRequest;
  static deserializeBinaryFromReader(message: GetIBCTransferTxsRequest, reader: jspb.BinaryReader): GetIBCTransferTxsRequest;
}

export namespace GetIBCTransferTxsRequest {
  export type AsObject = {
    sender: string,
    receiver: string,
    srcChannel: string,
    srcPort: string,
    destChannel: string,
    destPort: string,
    limit: number,
    skip: number,
  }
}

export class GetIBCTransferTxsResponse extends jspb.Message {
  clearFieldList(): void;
  getFieldList(): Array<IBCTransferTx>;
  setFieldList(value: Array<IBCTransferTx>): void;
  addField(value?: IBCTransferTx, index?: number): IBCTransferTx;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): GetIBCTransferTxsResponse.AsObject;
  static toObject(includeInstance: boolean, msg: GetIBCTransferTxsResponse): GetIBCTransferTxsResponse.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: GetIBCTransferTxsResponse, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): GetIBCTransferTxsResponse;
  static deserializeBinaryFromReader(message: GetIBCTransferTxsResponse, reader: jspb.BinaryReader): GetIBCTransferTxsResponse;
}

export namespace GetIBCTransferTxsResponse {
  export type AsObject = {
    fieldList: Array<IBCTransferTx.AsObject>,
  }
}

export class IBCTransferTx extends jspb.Message {
  getSender(): string;
  setSender(value: string): void;

  getReceiver(): string;
  setReceiver(value: string): void;

  getSourcePort(): string;
  setSourcePort(value: string): void;

  getSourceChannel(): string;
  setSourceChannel(value: string): void;

  getDestinationPort(): string;
  setDestinationPort(value: string): void;

  getDestinationChannel(): string;
  setDestinationChannel(value: string): void;

  getAmount(): string;
  setAmount(value: string): void;

  getDenom(): string;
  setDenom(value: string): void;

  getTimeoutHeight(): string;
  setTimeoutHeight(value: string): void;

  getTimeoutTimestamp(): number;
  setTimeoutTimestamp(value: number): void;

  getPacketSequence(): number;
  setPacketSequence(value: number): void;

  getDataHex(): Uint8Array | string;
  getDataHex_asU8(): Uint8Array;
  getDataHex_asB64(): string;
  setDataHex(value: Uint8Array | string): void;

  getState(): string;
  setState(value: string): void;

  clearTxHashesList(): void;
  getTxHashesList(): Array<string>;
  setTxHashesList(value: Array<string>): void;
  addTxHashes(value: string, index?: number): string;

  getCreatedAt(): string;
  setCreatedAt(value: string): void;

  getUpdatedAt(): string;
  setUpdatedAt(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): IBCTransferTx.AsObject;
  static toObject(includeInstance: boolean, msg: IBCTransferTx): IBCTransferTx.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: IBCTransferTx, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): IBCTransferTx;
  static deserializeBinaryFromReader(message: IBCTransferTx, reader: jspb.BinaryReader): IBCTransferTx;
}

export namespace IBCTransferTx {
  export type AsObject = {
    sender: string,
    receiver: string,
    sourcePort: string,
    sourceChannel: string,
    destinationPort: string,
    destinationChannel: string,
    amount: string,
    denom: string,
    timeoutHeight: string,
    timeoutTimestamp: number,
    packetSequence: number,
    dataHex: Uint8Array | string,
    state: string,
    txHashesList: Array<string>,
    createdAt: string,
    updatedAt: string,
  }
}

export class GetWasmCodesRequest extends jspb.Message {
  getLimit(): number;
  setLimit(value: number): void;

  getFromNumber(): number;
  setFromNumber(value: number): void;

  getToNumber(): number;
  setToNumber(value: number): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): GetWasmCodesRequest.AsObject;
  static toObject(includeInstance: boolean, msg: GetWasmCodesRequest): GetWasmCodesRequest.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: GetWasmCodesRequest, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): GetWasmCodesRequest;
  static deserializeBinaryFromReader(message: GetWasmCodesRequest, reader: jspb.BinaryReader): GetWasmCodesRequest;
}

export namespace GetWasmCodesRequest {
  export type AsObject = {
    limit: number,
    fromNumber: number,
    toNumber: number,
  }
}

export class GetWasmCodesResponse extends jspb.Message {
  hasPaging(): boolean;
  clearPaging(): void;
  getPaging(): Paging | undefined;
  setPaging(value?: Paging): void;

  clearDataList(): void;
  getDataList(): Array<WasmCode>;
  setDataList(value: Array<WasmCode>): void;
  addData(value?: WasmCode, index?: number): WasmCode;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): GetWasmCodesResponse.AsObject;
  static toObject(includeInstance: boolean, msg: GetWasmCodesResponse): GetWasmCodesResponse.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: GetWasmCodesResponse, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): GetWasmCodesResponse;
  static deserializeBinaryFromReader(message: GetWasmCodesResponse, reader: jspb.BinaryReader): GetWasmCodesResponse;
}

export namespace GetWasmCodesResponse {
  export type AsObject = {
    paging?: Paging.AsObject,
    dataList: Array<WasmCode.AsObject>,
  }
}

export class WasmCode extends jspb.Message {
  getCodeId(): number;
  setCodeId(value: number): void;

  getTxHash(): string;
  setTxHash(value: string): void;

  hasChecksum(): boolean;
  clearChecksum(): void;
  getChecksum(): Checksum | undefined;
  setChecksum(value?: Checksum): void;

  getCreatedAt(): number;
  setCreatedAt(value: number): void;

  getContractType(): string;
  setContractType(value: string): void;

  getVersion(): string;
  setVersion(value: string): void;

  hasPermission(): boolean;
  clearPermission(): void;
  getPermission(): ContractPermission | undefined;
  setPermission(value?: ContractPermission): void;

  getCodeSchema(): string;
  setCodeSchema(value: string): void;

  getCodeView(): string;
  setCodeView(value: string): void;

  getInstantiates(): number;
  setInstantiates(value: number): void;

  getCreator(): string;
  setCreator(value: string): void;

  getCodeNumber(): number;
  setCodeNumber(value: number): void;

  getProposalId(): number;
  setProposalId(value: number): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): WasmCode.AsObject;
  static toObject(includeInstance: boolean, msg: WasmCode): WasmCode.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: WasmCode, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): WasmCode;
  static deserializeBinaryFromReader(message: WasmCode, reader: jspb.BinaryReader): WasmCode;
}

export namespace WasmCode {
  export type AsObject = {
    codeId: number,
    txHash: string,
    checksum?: Checksum.AsObject,
    createdAt: number,
    contractType: string,
    version: string,
    permission?: ContractPermission.AsObject,
    codeSchema: string,
    codeView: string,
    instantiates: number,
    creator: string,
    codeNumber: number,
    proposalId: number,
  }
}

export class Checksum extends jspb.Message {
  getAlgorithm(): string;
  setAlgorithm(value: string): void;

  getHash(): string;
  setHash(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): Checksum.AsObject;
  static toObject(includeInstance: boolean, msg: Checksum): Checksum.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: Checksum, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): Checksum;
  static deserializeBinaryFromReader(message: Checksum, reader: jspb.BinaryReader): Checksum;
}

export namespace Checksum {
  export type AsObject = {
    algorithm: string,
    hash: string,
  }
}

export class ContractPermission extends jspb.Message {
  getAccessType(): number;
  setAccessType(value: number): void;

  getAddress(): string;
  setAddress(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): ContractPermission.AsObject;
  static toObject(includeInstance: boolean, msg: ContractPermission): ContractPermission.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: ContractPermission, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): ContractPermission;
  static deserializeBinaryFromReader(message: ContractPermission, reader: jspb.BinaryReader): ContractPermission;
}

export namespace ContractPermission {
  export type AsObject = {
    accessType: number,
    address: string,
  }
}

export class GetWasmCodeByIDRequest extends jspb.Message {
  getCodeId(): number;
  setCodeId(value: number): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): GetWasmCodeByIDRequest.AsObject;
  static toObject(includeInstance: boolean, msg: GetWasmCodeByIDRequest): GetWasmCodeByIDRequest.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: GetWasmCodeByIDRequest, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): GetWasmCodeByIDRequest;
  static deserializeBinaryFromReader(message: GetWasmCodeByIDRequest, reader: jspb.BinaryReader): GetWasmCodeByIDRequest;
}

export namespace GetWasmCodeByIDRequest {
  export type AsObject = {
    codeId: number,
  }
}

export class GetWasmCodeByIDResponse extends jspb.Message {
  getCodeId(): number;
  setCodeId(value: number): void;

  getTxHash(): string;
  setTxHash(value: string): void;

  hasChecksum(): boolean;
  clearChecksum(): void;
  getChecksum(): Checksum | undefined;
  setChecksum(value?: Checksum): void;

  getCreatedAt(): number;
  setCreatedAt(value: number): void;

  getContractType(): string;
  setContractType(value: string): void;

  getVersion(): string;
  setVersion(value: string): void;

  hasPermission(): boolean;
  clearPermission(): void;
  getPermission(): ContractPermission | undefined;
  setPermission(value?: ContractPermission): void;

  getCodeSchema(): string;
  setCodeSchema(value: string): void;

  getCodeView(): string;
  setCodeView(value: string): void;

  getInstantiates(): number;
  setInstantiates(value: number): void;

  getCreator(): string;
  setCreator(value: string): void;

  getCodeNumber(): number;
  setCodeNumber(value: number): void;

  getProposalId(): number;
  setProposalId(value: number): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): GetWasmCodeByIDResponse.AsObject;
  static toObject(includeInstance: boolean, msg: GetWasmCodeByIDResponse): GetWasmCodeByIDResponse.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: GetWasmCodeByIDResponse, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): GetWasmCodeByIDResponse;
  static deserializeBinaryFromReader(message: GetWasmCodeByIDResponse, reader: jspb.BinaryReader): GetWasmCodeByIDResponse;
}

export namespace GetWasmCodeByIDResponse {
  export type AsObject = {
    codeId: number,
    txHash: string,
    checksum?: Checksum.AsObject,
    createdAt: number,
    contractType: string,
    version: string,
    permission?: ContractPermission.AsObject,
    codeSchema: string,
    codeView: string,
    instantiates: number,
    creator: string,
    codeNumber: number,
    proposalId: number,
  }
}

export class GetWasmContractsRequest extends jspb.Message {
  getLimit(): number;
  setLimit(value: number): void;

  getCodeId(): number;
  setCodeId(value: number): void;

  getFromNumber(): number;
  setFromNumber(value: number): void;

  getToNumber(): number;
  setToNumber(value: number): void;

  getAssetsOnly(): boolean;
  setAssetsOnly(value: boolean): void;

  getSkip(): number;
  setSkip(value: number): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): GetWasmContractsRequest.AsObject;
  static toObject(includeInstance: boolean, msg: GetWasmContractsRequest): GetWasmContractsRequest.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: GetWasmContractsRequest, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): GetWasmContractsRequest;
  static deserializeBinaryFromReader(message: GetWasmContractsRequest, reader: jspb.BinaryReader): GetWasmContractsRequest;
}

export namespace GetWasmContractsRequest {
  export type AsObject = {
    limit: number,
    codeId: number,
    fromNumber: number,
    toNumber: number,
    assetsOnly: boolean,
    skip: number,
  }
}

export class GetWasmContractsResponse extends jspb.Message {
  hasPaging(): boolean;
  clearPaging(): void;
  getPaging(): Paging | undefined;
  setPaging(value?: Paging): void;

  clearDataList(): void;
  getDataList(): Array<WasmContract>;
  setDataList(value: Array<WasmContract>): void;
  addData(value?: WasmContract, index?: number): WasmContract;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): GetWasmContractsResponse.AsObject;
  static toObject(includeInstance: boolean, msg: GetWasmContractsResponse): GetWasmContractsResponse.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: GetWasmContractsResponse, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): GetWasmContractsResponse;
  static deserializeBinaryFromReader(message: GetWasmContractsResponse, reader: jspb.BinaryReader): GetWasmContractsResponse;
}

export namespace GetWasmContractsResponse {
  export type AsObject = {
    paging?: Paging.AsObject,
    dataList: Array<WasmContract.AsObject>,
  }
}

export class WasmContract extends jspb.Message {
  getLabel(): string;
  setLabel(value: string): void;

  getAddress(): string;
  setAddress(value: string): void;

  getTxHash(): string;
  setTxHash(value: string): void;

  getCreator(): string;
  setCreator(value: string): void;

  getExecutes(): number;
  setExecutes(value: number): void;

  getInstantiatedAt(): number;
  setInstantiatedAt(value: number): void;

  getInitMessage(): string;
  setInitMessage(value: string): void;

  getLastExecutedAt(): number;
  setLastExecutedAt(value: number): void;

  clearFundsList(): void;
  getFundsList(): Array<ContractFund>;
  setFundsList(value: Array<ContractFund>): void;
  addFunds(value?: ContractFund, index?: number): ContractFund;

  getCodeId(): number;
  setCodeId(value: number): void;

  getAdmin(): string;
  setAdmin(value: string): void;

  getCurrentMigrateMessage(): string;
  setCurrentMigrateMessage(value: string): void;

  getContractNumber(): number;
  setContractNumber(value: number): void;

  getVersion(): string;
  setVersion(value: string): void;

  getType(): string;
  setType(value: string): void;

  hasCw20Metadata(): boolean;
  clearCw20Metadata(): void;
  getCw20Metadata(): Cw20Metadata | undefined;
  setCw20Metadata(value?: Cw20Metadata): void;

  getProposalId(): number;
  setProposalId(value: number): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): WasmContract.AsObject;
  static toObject(includeInstance: boolean, msg: WasmContract): WasmContract.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: WasmContract, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): WasmContract;
  static deserializeBinaryFromReader(message: WasmContract, reader: jspb.BinaryReader): WasmContract;
}

export namespace WasmContract {
  export type AsObject = {
    label: string,
    address: string,
    txHash: string,
    creator: string,
    executes: number,
    instantiatedAt: number,
    initMessage: string,
    lastExecutedAt: number,
    fundsList: Array<ContractFund.AsObject>,
    codeId: number,
    admin: string,
    currentMigrateMessage: string,
    contractNumber: number,
    version: string,
    type: string,
    cw20Metadata?: Cw20Metadata.AsObject,
    proposalId: number,
  }
}

export class ContractFund extends jspb.Message {
  getDenom(): string;
  setDenom(value: string): void;

  getAmount(): string;
  setAmount(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): ContractFund.AsObject;
  static toObject(includeInstance: boolean, msg: ContractFund): ContractFund.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: ContractFund, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): ContractFund;
  static deserializeBinaryFromReader(message: ContractFund, reader: jspb.BinaryReader): ContractFund;
}

export namespace ContractFund {
  export type AsObject = {
    denom: string,
    amount: string,
  }
}

export class Cw20Metadata extends jspb.Message {
  hasTokenInfo(): boolean;
  clearTokenInfo(): void;
  getTokenInfo(): Cw20TokenInfo | undefined;
  setTokenInfo(value?: Cw20TokenInfo): void;

  hasMarketingInfo(): boolean;
  clearMarketingInfo(): void;
  getMarketingInfo(): Cw20MarketingInfo | undefined;
  setMarketingInfo(value?: Cw20MarketingInfo): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): Cw20Metadata.AsObject;
  static toObject(includeInstance: boolean, msg: Cw20Metadata): Cw20Metadata.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: Cw20Metadata, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): Cw20Metadata;
  static deserializeBinaryFromReader(message: Cw20Metadata, reader: jspb.BinaryReader): Cw20Metadata;
}

export namespace Cw20Metadata {
  export type AsObject = {
    tokenInfo?: Cw20TokenInfo.AsObject,
    marketingInfo?: Cw20MarketingInfo.AsObject,
  }
}

export class Cw20TokenInfo extends jspb.Message {
  getName(): string;
  setName(value: string): void;

  getSymbol(): string;
  setSymbol(value: string): void;

  getDecimals(): number;
  setDecimals(value: number): void;

  getTotalSupply(): string;
  setTotalSupply(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): Cw20TokenInfo.AsObject;
  static toObject(includeInstance: boolean, msg: Cw20TokenInfo): Cw20TokenInfo.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: Cw20TokenInfo, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): Cw20TokenInfo;
  static deserializeBinaryFromReader(message: Cw20TokenInfo, reader: jspb.BinaryReader): Cw20TokenInfo;
}

export namespace Cw20TokenInfo {
  export type AsObject = {
    name: string,
    symbol: string,
    decimals: number,
    totalSupply: string,
  }
}

export class Cw20MarketingInfo extends jspb.Message {
  getProject(): string;
  setProject(value: string): void;

  getDescription(): string;
  setDescription(value: string): void;

  getLogo(): string;
  setLogo(value: string): void;

  getMarketing(): Uint8Array | string;
  getMarketing_asU8(): Uint8Array;
  getMarketing_asB64(): string;
  setMarketing(value: Uint8Array | string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): Cw20MarketingInfo.AsObject;
  static toObject(includeInstance: boolean, msg: Cw20MarketingInfo): Cw20MarketingInfo.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: Cw20MarketingInfo, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): Cw20MarketingInfo;
  static deserializeBinaryFromReader(message: Cw20MarketingInfo, reader: jspb.BinaryReader): Cw20MarketingInfo;
}

export namespace Cw20MarketingInfo {
  export type AsObject = {
    project: string,
    description: string,
    logo: string,
    marketing: Uint8Array | string,
  }
}

export class GetWasmContractByAddressRequest extends jspb.Message {
  getContractAddress(): string;
  setContractAddress(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): GetWasmContractByAddressRequest.AsObject;
  static toObject(includeInstance: boolean, msg: GetWasmContractByAddressRequest): GetWasmContractByAddressRequest.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: GetWasmContractByAddressRequest, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): GetWasmContractByAddressRequest;
  static deserializeBinaryFromReader(message: GetWasmContractByAddressRequest, reader: jspb.BinaryReader): GetWasmContractByAddressRequest;
}

export namespace GetWasmContractByAddressRequest {
  export type AsObject = {
    contractAddress: string,
  }
}

export class GetWasmContractByAddressResponse extends jspb.Message {
  getLabel(): string;
  setLabel(value: string): void;

  getAddress(): string;
  setAddress(value: string): void;

  getTxHash(): string;
  setTxHash(value: string): void;

  getCreator(): string;
  setCreator(value: string): void;

  getExecutes(): number;
  setExecutes(value: number): void;

  getInstantiatedAt(): number;
  setInstantiatedAt(value: number): void;

  getInitMessage(): string;
  setInitMessage(value: string): void;

  getLastExecutedAt(): number;
  setLastExecutedAt(value: number): void;

  clearFundsList(): void;
  getFundsList(): Array<ContractFund>;
  setFundsList(value: Array<ContractFund>): void;
  addFunds(value?: ContractFund, index?: number): ContractFund;

  getCodeId(): number;
  setCodeId(value: number): void;

  getAdmin(): string;
  setAdmin(value: string): void;

  getCurrentMigrateMessage(): string;
  setCurrentMigrateMessage(value: string): void;

  getContractNumber(): number;
  setContractNumber(value: number): void;

  getVersion(): string;
  setVersion(value: string): void;

  getType(): string;
  setType(value: string): void;

  hasCw20Metadata(): boolean;
  clearCw20Metadata(): void;
  getCw20Metadata(): Cw20Metadata | undefined;
  setCw20Metadata(value?: Cw20Metadata): void;

  getProposalId(): number;
  setProposalId(value: number): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): GetWasmContractByAddressResponse.AsObject;
  static toObject(includeInstance: boolean, msg: GetWasmContractByAddressResponse): GetWasmContractByAddressResponse.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: GetWasmContractByAddressResponse, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): GetWasmContractByAddressResponse;
  static deserializeBinaryFromReader(message: GetWasmContractByAddressResponse, reader: jspb.BinaryReader): GetWasmContractByAddressResponse;
}

export namespace GetWasmContractByAddressResponse {
  export type AsObject = {
    label: string,
    address: string,
    txHash: string,
    creator: string,
    executes: number,
    instantiatedAt: number,
    initMessage: string,
    lastExecutedAt: number,
    fundsList: Array<ContractFund.AsObject>,
    codeId: number,
    admin: string,
    currentMigrateMessage: string,
    contractNumber: number,
    version: string,
    type: string,
    cw20Metadata?: Cw20Metadata.AsObject,
    proposalId: number,
  }
}

export class GetCw20BalanceRequest extends jspb.Message {
  getAddress(): string;
  setAddress(value: string): void;

  getLimit(): number;
  setLimit(value: number): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): GetCw20BalanceRequest.AsObject;
  static toObject(includeInstance: boolean, msg: GetCw20BalanceRequest): GetCw20BalanceRequest.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: GetCw20BalanceRequest, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): GetCw20BalanceRequest;
  static deserializeBinaryFromReader(message: GetCw20BalanceRequest, reader: jspb.BinaryReader): GetCw20BalanceRequest;
}

export namespace GetCw20BalanceRequest {
  export type AsObject = {
    address: string,
    limit: number,
  }
}

export class GetCw20BalanceResponse extends jspb.Message {
  clearFieldList(): void;
  getFieldList(): Array<WasmCw20Balance>;
  setFieldList(value: Array<WasmCw20Balance>): void;
  addField(value?: WasmCw20Balance, index?: number): WasmCw20Balance;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): GetCw20BalanceResponse.AsObject;
  static toObject(includeInstance: boolean, msg: GetCw20BalanceResponse): GetCw20BalanceResponse.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: GetCw20BalanceResponse, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): GetCw20BalanceResponse;
  static deserializeBinaryFromReader(message: GetCw20BalanceResponse, reader: jspb.BinaryReader): GetCw20BalanceResponse;
}

export namespace GetCw20BalanceResponse {
  export type AsObject = {
    fieldList: Array<WasmCw20Balance.AsObject>,
  }
}

export class WasmCw20Balance extends jspb.Message {
  getContractAddress(): string;
  setContractAddress(value: string): void;

  getAccount(): string;
  setAccount(value: string): void;

  getBalance(): string;
  setBalance(value: string): void;

  getUpdatedAt(): number;
  setUpdatedAt(value: number): void;

  hasCw20Metadata(): boolean;
  clearCw20Metadata(): void;
  getCw20Metadata(): Cw20Metadata | undefined;
  setCw20Metadata(value?: Cw20Metadata): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): WasmCw20Balance.AsObject;
  static toObject(includeInstance: boolean, msg: WasmCw20Balance): WasmCw20Balance.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: WasmCw20Balance, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): WasmCw20Balance;
  static deserializeBinaryFromReader(message: WasmCw20Balance, reader: jspb.BinaryReader): WasmCw20Balance;
}

export namespace WasmCw20Balance {
  export type AsObject = {
    contractAddress: string,
    account: string,
    balance: string,
    updatedAt: number,
    cw20Metadata?: Cw20Metadata.AsObject,
  }
}

export class RelayersRequest extends jspb.Message {
  clearMarketIDsList(): void;
  getMarketIDsList(): Array<string>;
  setMarketIDsList(value: Array<string>): void;
  addMarketIDs(value: string, index?: number): string;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): RelayersRequest.AsObject;
  static toObject(includeInstance: boolean, msg: RelayersRequest): RelayersRequest.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: RelayersRequest, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): RelayersRequest;
  static deserializeBinaryFromReader(message: RelayersRequest, reader: jspb.BinaryReader): RelayersRequest;
}

export namespace RelayersRequest {
  export type AsObject = {
    marketIDsList: Array<string>,
  }
}

export class RelayersResponse extends jspb.Message {
  clearFieldList(): void;
  getFieldList(): Array<RelayerMarkets>;
  setFieldList(value: Array<RelayerMarkets>): void;
  addField(value?: RelayerMarkets, index?: number): RelayerMarkets;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): RelayersResponse.AsObject;
  static toObject(includeInstance: boolean, msg: RelayersResponse): RelayersResponse.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: RelayersResponse, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): RelayersResponse;
  static deserializeBinaryFromReader(message: RelayersResponse, reader: jspb.BinaryReader): RelayersResponse;
}

export namespace RelayersResponse {
  export type AsObject = {
    fieldList: Array<RelayerMarkets.AsObject>,
  }
}

export class RelayerMarkets extends jspb.Message {
  getMarketId(): string;
  setMarketId(value: string): void;

  clearRelayersList(): void;
  getRelayersList(): Array<Relayer>;
  setRelayersList(value: Array<Relayer>): void;
  addRelayers(value?: Relayer, index?: number): Relayer;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): RelayerMarkets.AsObject;
  static toObject(includeInstance: boolean, msg: RelayerMarkets): RelayerMarkets.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: RelayerMarkets, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): RelayerMarkets;
  static deserializeBinaryFromReader(message: RelayerMarkets, reader: jspb.BinaryReader): RelayerMarkets;
}

export namespace RelayerMarkets {
  export type AsObject = {
    marketId: string,
    relayersList: Array<Relayer.AsObject>,
  }
}

export class Relayer extends jspb.Message {
  getName(): string;
  setName(value: string): void;

  getCta(): string;
  setCta(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): Relayer.AsObject;
  static toObject(includeInstance: boolean, msg: Relayer): Relayer.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: Relayer, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): Relayer;
  static deserializeBinaryFromReader(message: Relayer, reader: jspb.BinaryReader): Relayer;
}

export namespace Relayer {
  export type AsObject = {
    name: string,
    cta: string,
  }
}

export class StreamTxsRequest extends jspb.Message {
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): StreamTxsRequest.AsObject;
  static toObject(includeInstance: boolean, msg: StreamTxsRequest): StreamTxsRequest.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: StreamTxsRequest, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): StreamTxsRequest;
  static deserializeBinaryFromReader(message: StreamTxsRequest, reader: jspb.BinaryReader): StreamTxsRequest;
}

export namespace StreamTxsRequest {
  export type AsObject = {
  }
}

export class StreamTxsResponse extends jspb.Message {
  getId(): string;
  setId(value: string): void;

  getBlockNumber(): number;
  setBlockNumber(value: number): void;

  getBlockTimestamp(): string;
  setBlockTimestamp(value: string): void;

  getHash(): string;
  setHash(value: string): void;

  getCodespace(): string;
  setCodespace(value: string): void;

  getMessages(): string;
  setMessages(value: string): void;

  getTxNumber(): number;
  setTxNumber(value: number): void;

  getErrorLog(): string;
  setErrorLog(value: string): void;

  getCode(): number;
  setCode(value: number): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): StreamTxsResponse.AsObject;
  static toObject(includeInstance: boolean, msg: StreamTxsResponse): StreamTxsResponse.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: StreamTxsResponse, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): StreamTxsResponse;
  static deserializeBinaryFromReader(message: StreamTxsResponse, reader: jspb.BinaryReader): StreamTxsResponse;
}

export namespace StreamTxsResponse {
  export type AsObject = {
    id: string,
    blockNumber: number,
    blockTimestamp: string,
    hash: string,
    codespace: string,
    messages: string,
    txNumber: number,
    errorLog: string,
    code: number,
  }
}

export class StreamBlocksRequest extends jspb.Message {
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): StreamBlocksRequest.AsObject;
  static toObject(includeInstance: boolean, msg: StreamBlocksRequest): StreamBlocksRequest.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: StreamBlocksRequest, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): StreamBlocksRequest;
  static deserializeBinaryFromReader(message: StreamBlocksRequest, reader: jspb.BinaryReader): StreamBlocksRequest;
}

export namespace StreamBlocksRequest {
  export type AsObject = {
  }
}

export class StreamBlocksResponse extends jspb.Message {
  getHeight(): number;
  setHeight(value: number): void;

  getProposer(): string;
  setProposer(value: string): void;

  getMoniker(): string;
  setMoniker(value: string): void;

  getBlockHash(): string;
  setBlockHash(value: string): void;

  getParentHash(): string;
  setParentHash(value: string): void;

  getNumPreCommits(): number;
  setNumPreCommits(value: number): void;

  getNumTxs(): number;
  setNumTxs(value: number): void;

  clearTxsList(): void;
  getTxsList(): Array<TxDataRPC>;
  setTxsList(value: Array<TxDataRPC>): void;
  addTxs(value?: TxDataRPC, index?: number): TxDataRPC;

  getTimestamp(): string;
  setTimestamp(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): StreamBlocksResponse.AsObject;
  static toObject(includeInstance: boolean, msg: StreamBlocksResponse): StreamBlocksResponse.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: StreamBlocksResponse, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): StreamBlocksResponse;
  static deserializeBinaryFromReader(message: StreamBlocksResponse, reader: jspb.BinaryReader): StreamBlocksResponse;
}

export namespace StreamBlocksResponse {
  export type AsObject = {
    height: number,
    proposer: string,
    moniker: string,
    blockHash: string,
    parentHash: string,
    numPreCommits: number,
    numTxs: number,
    txsList: Array<TxDataRPC.AsObject>,
    timestamp: string,
  }
}

