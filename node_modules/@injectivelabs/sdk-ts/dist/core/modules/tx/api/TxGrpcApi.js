"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TxGrpcApi = void 0;
const service_pb_service_1 = require("@injectivelabs/chain-api/cosmos/tx/v1beta1/service_pb_service");
const service_pb_1 = require("@injectivelabs/chain-api/cosmos/tx/v1beta1/service_pb");
const grpc_web_1 = require("@injectivelabs/grpc-web");
const exceptions_1 = require("@injectivelabs/exceptions");
const grpc_1 = require("../../../../utils/grpc");
const helpers_1 = require("../../../../utils/helpers");
const utils_1 = require("@injectivelabs/utils");
if (!(0, helpers_1.isBrowser)()) {
    grpc_web_1.grpc.setDefaultTransport((0, grpc_1.getGrpcTransport)());
}
class TxGrpcApi {
    constructor(endpoint) {
        this.endpoint = endpoint;
        this.txService = new service_pb_service_1.ServiceClient(endpoint, {
            transport: (0, grpc_1.getGrpcTransport)(),
        });
    }
    fetchTx(hash) {
        return __awaiter(this, void 0, void 0, function* () {
            const request = new service_pb_1.GetTxRequest();
            request.setHash(hash);
            try {
                const response = yield this.request(request, service_pb_service_1.Service.GetTx);
                const txResponse = response.getTxResponse();
                if (!txResponse) {
                    throw new exceptions_1.GrpcUnaryRequestException(new Error(`The transaction with ${hash} is not found`), {
                        context: 'TxGrpcApi',
                        contextModule: 'fetch-tx',
                    });
                }
                if (txResponse.getCode() !== 0) {
                    throw new exceptions_1.TransactionException(new Error(txResponse.getRawLog()), {
                        contextCode: txResponse.getCode(),
                        contextModule: txResponse.getCodespace(),
                    });
                }
                return Object.assign(Object.assign({}, txResponse.toObject()), { txHash: txResponse.getTxhash() });
            }
            catch (e) {
                // Transaction has failed on the chain
                if (e instanceof exceptions_1.TransactionException) {
                    throw e;
                }
                // Failed to query the transaction on the chain
                if (e instanceof exceptions_1.GrpcUnaryRequestException) {
                    throw e;
                }
                // The response itself failed
                throw new exceptions_1.GrpcUnaryRequestException(new Error('There was an issue while fetching transaction details'), {
                    context: 'TxGrpcApi',
                    contextModule: 'fetch-tx',
                });
            }
        });
    }
    fetchTxPoll(txHash, timeout = utils_1.DEFAULT_TX_BLOCK_INCLUSION_TIMEOUT_IN_MS || 60000) {
        return __awaiter(this, void 0, void 0, function* () {
            const POLL_INTERVAL = utils_1.DEFAULT_BLOCK_TIME_IN_SECONDS * 1000;
            for (let i = 0; i <= timeout / POLL_INTERVAL; i += 1) {
                try {
                    const txResponse = yield this.fetchTx(txHash);
                    if (txResponse) {
                        return txResponse;
                    }
                }
                catch (e) {
                    // We throw only if the transaction failed on chain
                    if (e instanceof exceptions_1.TransactionException) {
                        throw e;
                    }
                }
                yield new Promise((resolve) => setTimeout(resolve, POLL_INTERVAL));
            }
            // Transaction was not included in the block in the desired timeout
            throw new exceptions_1.GrpcUnaryRequestException(new Error(`Transaction was not included in a block before timeout of ${timeout}ms`), {
                context: 'TxGrpcApi',
                contextModule: 'fetch-tx-poll',
            });
        });
    }
    simulate(txRaw) {
        return __awaiter(this, void 0, void 0, function* () {
            const { txService } = this;
            const txRawClone = txRaw.clone();
            const simulateRequest = new service_pb_1.SimulateRequest();
            if (txRawClone.getSignaturesList().length === 0) {
                txRawClone.setSignaturesList([new Uint8Array(0)]);
            }
            simulateRequest.setTxBytes(txRawClone.serializeBinary());
            try {
                return yield new Promise((resolve, reject) => txService.simulate(simulateRequest, (error, response) => {
                    if (error || !response) {
                        return reject(error);
                    }
                    const result = response.getResult();
                    const gasInfo = response.getGasInfo();
                    return resolve({
                        result: result ? result.toObject() : {},
                        gasInfo: gasInfo ? gasInfo.toObject() : {},
                    });
                }));
            }
            catch (e) {
                throw new exceptions_1.TransactionException(new Error(e.message));
            }
        });
    }
    broadcast(txRaw, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const { txService } = this;
            const { mode, timeout } = options || {
                mode: service_pb_1.BroadcastMode.BROADCAST_MODE_SYNC,
                timeout: utils_1.DEFAULT_TX_BLOCK_INCLUSION_TIMEOUT_IN_MS || 60000,
            };
            const broadcastTxRequest = new service_pb_1.BroadcastTxRequest();
            broadcastTxRequest.setTxBytes(txRaw.serializeBinary());
            broadcastTxRequest.setMode(mode);
            try {
                const response = yield new Promise((resolve, reject) => txService.broadcastTx(broadcastTxRequest, (error, response) => __awaiter(this, void 0, void 0, function* () {
                    if (error || !response) {
                        return reject(error);
                    }
                    return resolve(response);
                })));
                const txResponse = response.getTxResponse();
                if (txResponse.getCode() !== 0) {
                    throw new exceptions_1.TransactionException(new Error(txResponse.getRawLog()), {
                        contextCode: txResponse.getCode(),
                        contextModule: txResponse.getCodespace(),
                    });
                }
                return yield this.fetchTxPoll(txResponse.getTxhash(), timeout);
            }
            catch (e) {
                if (e instanceof exceptions_1.TransactionException) {
                    throw e;
                }
                throw new exceptions_1.TransactionException(new Error(e.message));
            }
        });
    }
    broadcastBlock(txRaw, broadcastMode = service_pb_1.BroadcastMode.BROADCAST_MODE_BLOCK) {
        return __awaiter(this, void 0, void 0, function* () {
            const { txService } = this;
            const broadcastTxRequest = new service_pb_1.BroadcastTxRequest();
            broadcastTxRequest.setTxBytes(txRaw.serializeBinary());
            broadcastTxRequest.setMode(broadcastMode);
            try {
                return yield new Promise((resolve, reject) => txService.broadcastTx(broadcastTxRequest, (error, response) => {
                    if (error || !response) {
                        return reject(error);
                    }
                    const txResponse = response.getTxResponse();
                    if (!txResponse) {
                        return reject(new Error('There was an issue broadcasting the transaction'));
                    }
                    const result = Object.assign(Object.assign({}, txResponse.toObject()), { txHash: txResponse.getTxhash() });
                    if (result.code !== 0) {
                        return reject(new exceptions_1.TransactionException(new Error(result.rawLog), {
                            contextCode: result.code,
                            contextModule: result.codespace,
                        }));
                    }
                    return resolve(result);
                }));
            }
            catch (e) {
                if (e instanceof exceptions_1.TransactionException) {
                    throw e;
                }
                throw new exceptions_1.TransactionException(new Error(e.message));
            }
        });
    }
    request(request, service) {
        return new Promise((resolve, reject) => {
            grpc_web_1.grpc.unary(service, {
                request,
                host: this.endpoint,
                onEnd: (res) => {
                    const { statusMessage, status, message } = res;
                    if (status === grpc_web_1.grpc.Code.OK && message) {
                        resolve(message);
                    }
                    reject(new Error(statusMessage));
                },
            });
        });
    }
}
exports.TxGrpcApi = TxGrpcApi;
//# sourceMappingURL=TxGrpcApi.js.map