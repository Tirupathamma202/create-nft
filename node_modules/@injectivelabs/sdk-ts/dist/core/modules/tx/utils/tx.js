"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getTransactionPartsFromTxRaw = exports.createWeb3Extension = exports.createTxRawEIP712 = exports.createCosmosSignDocFromTransaction = exports.createSigDoc = exports.createAuthInfo = exports.createSignerInfo = exports.createSigners = exports.createFee = exports.createBody = exports.getPublicKey = void 0;
const keys_pb_1 = require("@injectivelabs/chain-api/cosmos/crypto/secp256k1/keys_pb");
const keys_pb_2 = require("@injectivelabs/chain-api/cosmos/crypto/secp256k1/keys_pb");
const helpers_1 = require("./helpers");
const tx_pb_1 = require("@injectivelabs/chain-api/cosmos/tx/v1beta1/tx_pb");
const coin_pb_1 = require("@injectivelabs/chain-api/cosmos/base/v1beta1/coin_pb");
const tx_1 = require("cosmjs-types/cosmos/tx/v1beta1/tx");
const tx_ext_pb_1 = require("@injectivelabs/chain-api/injective/types/v1beta1/tx_ext_pb");
const getPublicKey = ({ chainId, key, }) => {
    let proto;
    let path;
    if (chainId.startsWith('injective')) {
        proto = new keys_pb_1.PubKey();
        path = '/injective.crypto.v1beta1.ethsecp256k1.PubKey';
    }
    else if (chainId.startsWith('evmos')) {
        proto = new keys_pb_1.PubKey();
        path = '/ethermint.crypto.v1.ethsecp256k1.PubKey';
    }
    else {
        proto = new keys_pb_2.PubKey();
        path = '/cosmos.crypto.secp256k1.PubKey';
    }
    proto.setKey(Buffer.from(key, 'base64'));
    return (0, helpers_1.createAny)(proto.serializeBinary(), path);
};
exports.getPublicKey = getPublicKey;
const createBody = ({ message, memo = '', timeoutHeight, }) => {
    const messages = Array.isArray(message) ? message : [message];
    const txBody = new tx_pb_1.TxBody();
    txBody.setMessagesList(messages.map((message) => (0, helpers_1.createAnyMessage)({
        value: message.message,
        type: message.type,
    })));
    txBody.setMemo(memo);
    if (timeoutHeight) {
        txBody.setTimeoutHeight(timeoutHeight);
    }
    return txBody;
};
exports.createBody = createBody;
const createFee = ({ fee, payer, gasLimit, }) => {
    const feeAmount = new coin_pb_1.Coin();
    feeAmount.setAmount(fee.amount);
    feeAmount.setDenom(fee.denom);
    const feeProto = new tx_pb_1.Fee();
    feeProto.setGasLimit(gasLimit);
    feeProto.setAmountList([feeAmount]);
    if (payer) {
        feeProto.setPayer(payer);
    }
    return feeProto;
};
exports.createFee = createFee;
const createSigners = ({ chainId, mode, signers, }) => {
    return signers.map((s) => (0, exports.createSignerInfo)({
        mode,
        chainId,
        publicKey: s.pubKey,
        sequence: s.sequence,
    }));
};
exports.createSigners = createSigners;
const createSignerInfo = ({ chainId, publicKey, sequence, mode, }) => {
    const pubKey = (0, exports.getPublicKey)({ chainId, key: publicKey });
    const single = new tx_pb_1.ModeInfo.Single();
    single.setMode(mode);
    const modeInfo = new tx_pb_1.ModeInfo();
    modeInfo.setSingle(single);
    const signerInfo = new tx_pb_1.SignerInfo();
    signerInfo.setPublicKey(pubKey);
    signerInfo.setSequence(sequence);
    signerInfo.setModeInfo(modeInfo);
    return signerInfo;
};
exports.createSignerInfo = createSignerInfo;
const createAuthInfo = ({ signerInfo, fee, }) => {
    const authInfo = new tx_pb_1.AuthInfo();
    authInfo.setSignerInfosList(signerInfo);
    authInfo.setFee(fee);
    return authInfo;
};
exports.createAuthInfo = createAuthInfo;
const createSigDoc = ({ bodyBytes, authInfoBytes, chainId, accountNumber, }) => {
    const signDoc = new tx_pb_1.SignDoc();
    signDoc.setAccountNumber(accountNumber);
    signDoc.setChainId(chainId);
    signDoc.setBodyBytes(bodyBytes);
    signDoc.setAuthInfoBytes(authInfoBytes);
    return signDoc;
};
exports.createSigDoc = createSigDoc;
const createCosmosSignDocFromTransaction = (args) => {
    return tx_1.SignDoc.fromPartial({
        bodyBytes: args.txRaw.getBodyBytes_asU8(),
        authInfoBytes: args.txRaw.getAuthInfoBytes_asU8(),
        accountNumber: args.accountNumber,
        chainId: args.chainId,
    });
};
exports.createCosmosSignDocFromTransaction = createCosmosSignDocFromTransaction;
const createTxRawEIP712 = (txRaw, extension) => {
    const body = tx_pb_1.TxBody.deserializeBinary(txRaw.getBodyBytes_asU8());
    const extensionAny = (0, helpers_1.createAny)(extension.serializeBinary(), '/injective.types.v1beta1.ExtensionOptionsWeb3Tx');
    body.addExtensionOptions(extensionAny);
    txRaw.setBodyBytes(body.serializeBinary());
    return txRaw;
};
exports.createTxRawEIP712 = createTxRawEIP712;
const createWeb3Extension = ({ ethereumChainId, feePayer, feePayerSig, }) => {
    const web3Extension = new tx_ext_pb_1.ExtensionOptionsWeb3Tx();
    web3Extension.setTypeddatachainid(ethereumChainId);
    if (feePayer) {
        web3Extension.setFeepayer(feePayer);
    }
    if (feePayerSig) {
        web3Extension.setFeepayersig(feePayerSig);
    }
    return web3Extension;
};
exports.createWeb3Extension = createWeb3Extension;
const getTransactionPartsFromTxRaw = (txRaw) => {
    const authInfo = tx_pb_1.AuthInfo.deserializeBinary(txRaw.getAuthInfoBytes_asU8());
    const body = tx_pb_1.TxBody.deserializeBinary(txRaw.getBodyBytes_asU8());
    return {
        body,
        authInfo,
        signatures: txRaw.getSignaturesList_asU8(),
    };
};
exports.getTransactionPartsFromTxRaw = getTransactionPartsFromTxRaw;
//# sourceMappingURL=tx.js.map